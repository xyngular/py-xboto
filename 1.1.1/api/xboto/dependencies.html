<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>xboto.dependencies API documentation</title>
<meta name="description" content="A few classes/resources that let you use a lazily created boto resource/client,
in a thread-safe manner: â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>xboto.dependencies</code></h1>
</header>
<section id="section-intro">
<p>A few classes/resources that let you use a lazily created boto resource/client,
in a thread-safe manner:</p>
<p>Normally, you would just get it via an attribute name, in this version you</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; boto_clients.ssm.get_paginator()
</code></pre>
<p>Or you can import it like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xboto.client import ssm
&gt;&gt;&gt; ssm.get_paginator()
</code></pre>
<p>Same with resources:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; boto_resources.dynamodb.Table(&quot;some-table&quot;)
</code></pre>
<p>Or</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xboto.client import dynamodb
&gt;&gt;&gt; dynamodb.Table(&quot;some-table&quot;)
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
A few classes/resources that let you use a lazily created boto resource/client,
in a thread-safe manner:

Normally, you would just get it via an attribute name, in this version you

&gt;&gt;&gt; boto_clients.ssm.get_paginator()

Or you can import it like so:

&gt;&gt;&gt; from xboto.client import ssm
&gt;&gt;&gt; ssm.get_paginator()

Same with resources:

&gt;&gt;&gt; boto_resources.dynamodb.Table(&#34;some-table&#34;)

Or

&gt;&gt;&gt; from xboto.client import dynamodb
&gt;&gt;&gt; dynamodb.Table(&#34;some-table&#34;)
&#34;&#34;&#34;
from typing import Any, Optional, Dict, Type, Callable

import boto3
import botocore
from botocore.session import Session
from xsentinels import Singleton
from xinject import Dependency, XContext


class BotoSession(Dependency):
    &#34;&#34;&#34;
    You can use this as an easy way to get a shared boto-session for the current thread.

    Right now only used with `_Loader` subclasses such as `BotoClients` and `BotoResources`.

    Boto Sessions are NOT thread-safe.
    When user is not using a session to create a client/resource,
    boto3 uses an internal/default session instead which is not thread-safe.

    - Or the docs for boto about this:
        - https://boto3.amazonaws.com/v1/documentation/api/latest/guide/session.html
    - For various examples see issue where people talk about it:
        - https://github.com/boto/botocore/issues/1246
    &#34;&#34;&#34;

    @property
    def session(self) -&gt; boto3.Session:
        if session := self._session:
            return session
        session = boto3.Session(**self._session_kwargs)
        self._session = session
        return session

    def __init__(
            self, *,
            reset_session_when_activated=False,
            aws_access_key_id: Optional[str] = None,
            aws_secret_access_key: Optional[str] = None,
            aws_session_token: Optional[str] = None,
            region_name: Optional[str] = None,
            botocore_session: Optional[Session] = None,
            profile_name: Optional[str] = None,
            **session_kwargs
    ):
        &#34;&#34;&#34;

        Args:
            reset_session_when_activated: If True: when self is activated
                (ie: made the current resource/dependency)
                will automatically call `BotoSession.reset_session()`, and therefore next time
                `BotoSession.session` is asked for will lazily allocate new boto Session.
                This is useful for unit-tests, where you really do want to create a new
                session/connection each time the unit-test is called if you use
                `BotoSession` as a decorator to a unit-testing method.

                If False (default): will keep any session that has been previously/lazily created.
                This keeps the connections around for you; hence why it&#39;s the default option.

            aws_access_key_id (str):  access key ID
            aws_secret_access_key (str): AWS secret access key
            aws_session_token (str): AWS temporary session token
            region_name (str): Default region when creating new connections
            botocore_session (botocore.session.Session): Use this Botocore session instead of
                creating a new default one.
            profile_name (str): The name of a profile to use. If not given, then the default
                profile is used.
            **session_kwargs: Pass additional args for boto Session here
                (for additional args that boto3 might add in the future).
        &#34;&#34;&#34;
        # Easily grab all boto args passed into us...
        args = {k: v for k, v in locals().items() if v is not None}
        args.pop(&#39;self&#39;, None)
        args.pop(&#39;reset_session_when_activated&#39;, None)
        args.pop(&#39;session_kwargs&#39;, None)

        # Remember args...
        self.reset_session_when_activated = reset_session_when_activated
        self._session_kwargs = {**args, **session_kwargs}
        self._boto_obj_store = {}

    def context_resource_for_copy(
            self, *, current_context: XContext, copied_context: XContext
    ) -&gt; &#39;BotoSession&#39;:
        if self.reset_session_when_activated:
            self.reset_session()
        return self

    @property
    def session_kwargs(self) -&gt; Dict[str, Any]:
        return self._session_kwargs.copy()

    @session_kwargs.setter
    def session_kwargs(self, value: Dict[str, Any]):
        self._session_kwargs = {**value}
        self.reset_session()

    def reset_session(self):
        # We will lazily create session and their associated boto-objs in the future as needed.
        self._session = None
        self._boto_obj_store = {}

    _session: Optional[boto3.Session] = None
    _session_kwargs: dict
    _boto_obj_store: dict

    def _boto_obj_for_dependency(
            self,
            dependency: &#39;_BaseBotoClientOrResource&#39;,
            constructor: Callable,
            force_create: bool = False
    ):
        if not force_create and (boto_obj := self._boto_obj_store.get(dependency)):
            return boto_obj

        boto_obj = constructor()
        self._boto_obj_store[dependency] = boto_obj
        return boto_obj

    def _reset_boto_obj_for_dependency(self, dependency: &#39;_BaseBotoClientOrResource&#39;):
        self._boto_obj_store.pop(dependency, None)


boto_session = BotoSession.proxy()
&#34;&#34;&#34; You can use this as the current &#39;boto&#39; session object.
    `_Loader` subclasses use this right now (see below).
&#34;&#34;&#34;


class _BaseBotoClientOrResource(Dependency):
    # Instead of inheriting from `ThreadUnsafeResource`, we set flag directly ourselves.
    # This allows us to be compatible with both v2 and v3 of xyn_resource.
    resource_thread_safe = False

    # Class Vars
    _boto_name: str = &#39;&#39;
    _boto_kind: str = &#39;&#39;

    # Instance Vars

    # These are used to keep track of how we configure(d) the boto client/resource.
    _boto_kwargs: Dict[str, Any]

    def __init__(
            self, region_name=None,
            api_version=None,
            use_ssl=None,
            verify=None,
            endpoint_url=None,
            aws_access_key_id=None,
            aws_secret_access_key=None,
            aws_session_token=None,
            config=None,
            **boto_kwargs
    ):
        &#34;&#34;&#34;
        You can specify any of the boto client/resource args, the known ones have been
        specififed and documented out.
        
        If there are ones in the future that are new or we don&#39;t know about, you can
        still specify them, they will be passed to us in `boto_kwargs`, which will be
        used as addtional kwargs when creating new boto client/resource.
        
        Args:
            region_name: The name of the region associated with the client. A client is associated
                with a single region.
            api_version: The API version to use. By default, botocore will use the latest API
                version when creating a client.You only need to specify this parameter if you want
                to use a previous API version of the client.
            use_ssl: Whether or not to use SSL. By default, SSL is used. Note that not all
                services support non-ssl connections.
            verify: Whether or not to verify SSL certificates. By default SSL certificates are
                verified. You can provide the following values:

                - False - do not validate SSL certificates. SSL will still be used
                    (unless use_ssl is False), but SSL certificates will not be verified.
                - path/to/cert/bundle.pem - A filename of the CA cert bundle to uses.
                    You can specify this argument if you want to use a different CA cert bundle
                    than the one used by botocore.
            endpoint_url: The complete URL to use for the constructed client.
                Normally, botocore will automatically construct the appropriate URL to use when
                communicating with a service. You can specify a complete URL
                (including the &#34;http/https&#34; scheme) to override this behavior.
                If this value is provided, then use_ssl is ignored.
            aws_access_key_id: The access key to use when creating the client.
                This is entirely optional, and if not provided, the credentials configured for the
                session will automatically be used. You only need to provide this argument if you
                want to override the credentials used for this specific client.
            aws_secret_access_key: The secret key to use when creating the client.
                Same semantics as aws_access_key_id above.
            aws_session_token: The session token to use when creating the client.
                Same semantics as aws_access_key_id above.
            config: Advanced client configuration options.
                If region_name is specified in the client config, its value will take precedence
                over environment variables and configuration values, but not over a region_name
                value passed explicitly to the method. If user_agent_extra is specified in the
                client config, it overrides the default user_agent_extra provided by the resource
                API. See
                [botocore config documentation](https://botocore.amazonaws.com/v1/documentation/api/latest/reference/config.html)
                for more details.
            **boto_kwargs:
        &#34;&#34;&#34;  # noqa -- url can&#39;t be broken up.
        # Easily grab all boto args passed into us...
        args = {k: v for k, v in locals().items() if v is not None}
        args.pop(&#39;self&#39;, None)
        args.pop(&#39;boto_kwargs&#39;, None)

        self._boto_kwargs = {**args, **boto_kwargs}

    def __init_subclass__(cls, boto_name: str = &#39;&#39;, boto_kind: str = &#39;&#39;, **kwargs):
        super().__init_subclass__(**kwargs)
        cls._boto_name = boto_name
        cls._boto_kind = boto_kind

    def reset(self):
        &#34;&#34;&#34; Resets the client; it will be re-created lazily next time it&#39;s asked for.
        &#34;&#34;&#34;
        # noinspection PyProtectedMember
        BotoSession.grab()._reset_boto_obj_for_dependency(self)

    def get(self):
        # If user specified their own &#39;endpoint_url&#39;, we are not using the default.
        # Otherwise, check to make sure settings value is still same as what we used;
        # we want a new object if the default endpoint_url has changed...
        #
        # For now, we just throw-away any old object if default has changed and user did not
        # specify their own endpoint_url value. If it changes frequently for some reason we
        # could optimize by store a client per-endpoint_url value, so we can reuse old
        # client when old values are restored.

        def constructor():
            # `kind` is either &#39;client&#39; or &#39;resource&#39;, we get the correct creation method...
            boto_creation_method = getattr(boto_session.session, self._boto_kind)

            # We then call creation method with the resource/client name and any other kwargs;
            # For the kwargs, we start with any defaults and then add in user specified ones...
            return boto_creation_method(
                self._boto_name, **self._boto_kwargs
            )

        # noinspection PyProtectedMember
        return BotoSession.grab()._boto_obj_for_dependency(self, constructor)

    @classmethod
    def _get_dependency_cls(cls, boto_name: str) -&gt; &#39;Type[_BaseBotoClientOrResource]&#39;:
        boto_kind = cls._boto_kind

        # Normalize name...
        # Client/Resources names never use `_`, they use a `-` instead.
        # Replace any `_` with a `-`
        # (allows one to still get it via attributes, vs having to pass a str into a/the method)
        boto_name = boto_name.replace(&#34;_&#34;, &#34;-&#34;)
        boto_name = boto_name.lower()

        if boto_name.endswith(&#34;-&#34;):
            # Remove ending underscore (ie: for the `lambda_` name).
            boto_name = boto_name[:-1]

        if dep_cls := _dependency_classes[boto_kind].get(boto_name):
            return dep_cls

        # We are creating a new type/class lazily based on the required boto resource/client...
        cls_name = f&#39;{boto_name.capitalize()}{boto_kind.capitalize()}&#39;
        dep_cls: Any = type(cls_name, (cls,), {}, boto_name=boto_name, boto_kind=boto_kind)

        # Store the type for future use.
        _dependency_classes[boto_kind][boto_name] = dep_cls
        return dep_cls

    @classmethod
    def get_dependency_cls(cls, boto_name: str) -&gt; &#39;Type[_BaseBotoClientOrResource]&#39;:
        raise NotImplementedError(&#34;Need to implement `get_dependency_cls` class method&#34;)

    @property
    def boto_kwargs(self) -&gt; Dict[str, Any]:
        &#34;&#34;&#34;
        Returns a copy of the boto_kwargs assigned either while creating object in init
        `_BaseBotoClientOrResource.__init__ or changed via `boto_kwargs` setter property
        after it was created.

        Any settings defined in dict will be passed to boto-client/resource when it&#39;s lazily
        created.
        &#34;&#34;&#34;
        return self._boto_kwargs.copy()

    @boto_kwargs.setter
    def boto_kwargs(self, value: Dict[str, Any]):
        &#34;&#34;&#34;
        Makes a copy of value and will use them as the boto_kwargs.

        Any settings defined in dict will be passed to boto-client/resource when it&#39;s lazily
        created.

        After property is set, will call `_BaseBotoClientOrResource.reset` so that the next
        time that a boto-client/resource is asked of me I&#39;ll lazily create a new client/resource
        with the setting provided to this property-setter.
        &#34;&#34;&#34;
        self._boto_kwargs = {**value}
        self.reset()


class BotoClient(_BaseBotoClientOrResource, boto_kind=&#39;client&#39;):
    @property
    def boto_client(self):
        return self.get()

    @classmethod
    def get_dependency_cls(cls, boto_name: str) -&gt; &#39;Type[BotoClient]&#39;:
        return cls._get_dependency_cls(boto_name)


class BotoResource(_BaseBotoClientOrResource, boto_kind=&#39;resource&#39;):
    @property
    def boto_resource(self):
        return self.get()

    @classmethod
    def get_dependency_cls(cls, boto_name: str) -&gt; &#39;Type[BotoResource]&#39;:
        return cls._get_dependency_cls(boto_name)


_dependency_classes: Dict[str, Dict[str, Type[BotoClient]]] = {
    &#39;resource&#39;: {},
    &#39;client&#39;: {}
}


class _LoaderMetaclass(type):
    _boto_dependency_class: Type[_BaseBotoClientOrResource]

    def __getattr__(self, key: str):
        if not key[0].isupper():
            raise AttributeError(
                f&#34;BotoClient/BotoResource classes start with an upper-case char, &#34;
                f&#34;was instead given ({key}).&#34;
            )
        try:
            return self._boto_dependency_class.get_dependency_cls(key)
        except Exception as e:
            raise AttributeError(
                f&#34;BotoClient/BotoResource class does not exist for key ({key}) &#34;
                f&#34;start with an upper-case char, was instead given ({key}).&#34;
            )


class _Loader(Dependency, metaclass=_LoaderMetaclass):
    def __init_subclass__(
            cls, boto_dependency_class: Optional[Type[_BaseBotoClientOrResource]] = None, **kwargs
    ):
        assert boto_dependency_class, (
            f&#34;Subclass {cls} need to pass in `boto_dependency_class` class arg.&#34;
        )
        cls._boto_dependency_class = boto_dependency_class

    def load(self, module):
        &#34;&#34;&#34;
        This is a way you can use a dynamic string to grab a boto3 client/resource by name.

        Normally, you would want to use one of these ways of doing it instead:

        &gt;&gt;&gt; from xboto import boto_clients
        &gt;&gt;&gt; boto_clients.ssm

        Or you can import it like so:

        &gt;&gt;&gt; from xboto.client import ssm

        And then you can use this ssm client just like the real one:

        &gt;&gt;&gt; ssm.get_paginator(...)

        There are also equivelent things for resources (like the client examples above)
        at `xboto.resource` and `xboto.boto_resources`.

        If you want to use a normal string to look up the client or resource,
        that&#39;s when you can use this load method.

        You can look up a boto3 client/resource via this method by passing in its name.
        You&#39;ll want to use a subclass of `_Loader` such as `BotoClients` or `BotoResources`.

        See thoese classes for more details, here are some quick examples:

        &gt;&gt;&gt; BotoResources.grab().load(&#39;dynamodb&#39;)

        or

        &gt;&gt;&gt; boto_resources.load(&#39;dynamodb&#39;)

        or

        &gt;&gt;&gt; BotoClients.grab().load(&#39;ssm&#39;)

        or

        &gt;&gt;&gt; boto_clients.load(&#39;ssm&#39;)
        &#34;&#34;&#34;

        # We cache the clients/resources directly on &#39;self&#39; (object),
        # using `module` as the attr-name (see `_Loader.__getattr__`)
        return getattr(self, module)

    def _lookup(self, module):
        &#34;&#34;&#34;Implemented in subclasses to look up the module from boto3 properly.&#34;&#34;&#34;
        raise NotImplementedError(f&#34;Need to implement `_lookup` in subclass ({self}).&#34;)

    def __getattribute__(self, item):
        &#34;&#34;&#34;
        Grabs a client/resource and stores it on self, returns it.

        Args:
            item: item-name to get

        Returns:

        &#34;&#34;&#34;
        try:
            return super().__getattribute__(item)
        except AttributeError:
            client = self._lookup(item)
            return client


class BotoClients(_Loader, boto_dependency_class=BotoClient):
    &#34;&#34;&#34;
    When you get an attribute off of me, I&#39;ll attempt to ask the boto3 library to allocate
    a client of the same type, and then store itself, so I return the same client again
    in the future.

    Right now, we will lazily allocate a boto3 client per-thread, and we will use the
    per-thread shared boto3 session resource to do it (ie: `_BotoSession.session`).

    You can also easily import and use the `boto_clients` proxy object
    (defined at top module-level).

    You can use `boto_clients` exactly the same as using `BotoClients.grab()`,
    making it more convenient to use since you can directly import `boto_clients`.

    &gt;&gt;&gt; from xboto import boto_clients
    &gt;&gt;&gt; # Showing here how you could use it:
    &gt;&gt;&gt; boto_clients.ssm.get_paginator(...)

    If you have an aws client that uses a `-` for it&#39;s name, you can use an `_` (underscore)
    instead.
    All underscores are changed to a `-` when looking up the aws client.
    You can also directly use the `xboto.dependencies.BotoClients.load` method, and use a `-`
    there.
    &#34;&#34;&#34;

    def _lookup(self, module):
        return BotoClient.get_dependency_cls(module).grab().boto_client

    # These annotations are only for IDE-type-completion;
    # any client boto supports will work regardless (even if not listed below).
    #
    # These are the xyn-resource `Resource` types/classes; ie: BotoClient subclasses
    # (start with upper-case letter)
    AccessAnalyzer: Type[BotoClient]
    Account: Type[BotoClient]
    Acm: Type[BotoClient]
    Acm_Pca: Type[BotoClient]
    AlexaForBusiness: Type[BotoClient]
    Amp: Type[BotoClient]
    Amplify: Type[BotoClient]
    AmplifyBackend: Type[BotoClient]
    AmplifyUiBuilder: Type[BotoClient]
    ApiGateway: Type[BotoClient]
    ApiGatewayManagementApi: Type[BotoClient]
    ApiGatewayV2: Type[BotoClient]
    AppConfig: Type[BotoClient]
    AppConfigData: Type[BotoClient]
    Appflow: Type[BotoClient]
    AppIntegrations: Type[BotoClient]
    Application_Autoscaling: Type[BotoClient]
    Application_Insights: Type[BotoClient]
    Applicationcostprofiler: Type[BotoClient]
    Appmesh: Type[BotoClient]
    Apprunner: Type[BotoClient]
    Appstream: Type[BotoClient]
    Appsync: Type[BotoClient]
    Arc_Zonal_Shift: Type[BotoClient]
    Athena: Type[BotoClient]
    AuditManager: Type[BotoClient]
    Autoscaling: Type[BotoClient]
    Autoscaling_Plans: Type[BotoClient]
    Backup: Type[BotoClient]
    Backup_Gateway: Type[BotoClient]
    BackupStorage: Type[BotoClient]
    Batch: Type[BotoClient]
    BillingConductor: Type[BotoClient]
    Braket: Type[BotoClient]
    Budgets: Type[BotoClient]
    Ce: Type[BotoClient]
    Chime: Type[BotoClient]
    Chime_Sdk_Identity: Type[BotoClient]
    Chime_Sdk_Media_Pipelines: Type[BotoClient]
    Chime_Sdk_Meetings: Type[BotoClient]
    Chime_Sdk_Messaging: Type[BotoClient]
    Chime_Sdk_Voice: Type[BotoClient]
    Cleanrooms: Type[BotoClient]
    Cloud9: Type[BotoClient]
    Cloudcontrol: Type[BotoClient]
    Clouddirectory: Type[BotoClient]
    Cloudformation: Type[BotoClient]
    Cloudfront: Type[BotoClient]
    Cloudhsm: Type[BotoClient]
    Cloudhsmv2: Type[BotoClient]
    Cloudsearch: Type[BotoClient]
    Cloudsearchdomain: Type[BotoClient]
    Cloudtrail: Type[BotoClient]
    Cloudtrail_Data: Type[BotoClient]
    Cloudwatch: Type[BotoClient]
    CodeArtifact: Type[BotoClient]
    CodeBuild: Type[BotoClient]
    CodeCatalyst: Type[BotoClient]
    CodeCommit: Type[BotoClient]
    CodeDeploy: Type[BotoClient]
    Codeguru_Reviewer: Type[BotoClient]
    CodeguruProfiler: Type[BotoClient]
    CodePipeline: Type[BotoClient]
    Codestar: Type[BotoClient]
    Codestar_Connections: Type[BotoClient]
    Codestar_Notifications: Type[BotoClient]
    Cognito_Identity: Type[BotoClient]
    Cognito_Idp: Type[BotoClient]
    Cognito_Sync: Type[BotoClient]
    Comprehend: Type[BotoClient]
    Comprehendmedical: Type[BotoClient]
    Compute_Optimizer: Type[BotoClient]
    Config: Type[BotoClient]
    Connect: Type[BotoClient]
    Connect_Contact_Lens: Type[BotoClient]
    ConnectCampaigns: Type[BotoClient]
    ConnectCases: Type[BotoClient]
    ConnectParticipant: Type[BotoClient]
    ControlTower: Type[BotoClient]
    Cur: Type[BotoClient]
    Customer_Profiles: Type[BotoClient]
    DataBrew: Type[BotoClient]
    DataExchange: Type[BotoClient]
    DataPipeline: Type[BotoClient]
    DataSync: Type[BotoClient]
    Dax: Type[BotoClient]
    Detective: Type[BotoClient]
    Devicefarm: Type[BotoClient]
    Devops_Guru: Type[BotoClient]
    DirectConnect: Type[BotoClient]
    Discovery: Type[BotoClient]
    Dlm: Type[BotoClient]
    Dms: Type[BotoClient]
    Docdb: Type[BotoClient]
    Docdb_Elastic: Type[BotoClient]
    Drs: Type[BotoClient]
    Ds: Type[BotoClient]
    DynamoDb: Type[BotoClient]
    DynamoDbStreams: Type[BotoClient]
    Ebs: Type[BotoClient]
    Ec2: Type[BotoClient]
    Ec2_Instance_Connect: Type[BotoClient]
    Ecr: Type[BotoClient]
    Ecr_Public: Type[BotoClient]
    Ecs: Type[BotoClient]
    Efs: Type[BotoClient]
    Eks: Type[BotoClient]
    Elastic_Inference: Type[BotoClient]
    Elasticache: Type[BotoClient]
    ElasticBeanstalk: Type[BotoClient]
    ElasticTranscoder: Type[BotoClient]
    Elb: Type[BotoClient]
    Elbv2: Type[BotoClient]
    Emr: Type[BotoClient]
    Emr_Containers: Type[BotoClient]
    Emr_Serverless: Type[BotoClient]
    Es: Type[BotoClient]
    Events: Type[BotoClient]
    Evidently: Type[BotoClient]
    Finspace: Type[BotoClient]
    Finspace_Data: Type[BotoClient]
    Firehose: Type[BotoClient]
    Fis: Type[BotoClient]
    Fms: Type[BotoClient]
    Forecast: Type[BotoClient]
    Forecastquery: Type[BotoClient]
    Frauddetector: Type[BotoClient]
    Fsx: Type[BotoClient]
    Gamelift: Type[BotoClient]
    Gamesparks: Type[BotoClient]
    Glacier: Type[BotoClient]
    Globalaccelerator: Type[BotoClient]
    Glue: Type[BotoClient]
    Grafana: Type[BotoClient]
    Greengrass: Type[BotoClient]
    Greengrassv2: Type[BotoClient]
    Groundstation: Type[BotoClient]
    Guardduty: Type[BotoClient]
    Health: Type[BotoClient]
    Healthlake: Type[BotoClient]
    Honeycode: Type[BotoClient]
    Iam: Type[BotoClient]
    IdentityStore: Type[BotoClient]
    ImageBuilder: Type[BotoClient]
    ImportExport: Type[BotoClient]
    Inspector: Type[BotoClient]
    Inspector2: Type[BotoClient]
    Iot: Type[BotoClient]
    Iot_Data: Type[BotoClient]
    Iot_Jobs_Data: Type[BotoClient]
    Iot_Roborunner: Type[BotoClient]
    Iot1Click_Devices: Type[BotoClient]
    Iot1Click_Projects: Type[BotoClient]
    IotAnalytics: Type[BotoClient]
    IotDeviceAdvisor: Type[BotoClient]
    IotEvents: Type[BotoClient]
    IotEvents_Data: Type[BotoClient]
    IotFleethub: Type[BotoClient]
    IotFleetwise: Type[BotoClient]
    IotSecureTunneling: Type[BotoClient]
    IotSitewise: Type[BotoClient]
    IotThingsgraph: Type[BotoClient]
    IotTwinmaker: Type[BotoClient]
    IotWireless: Type[BotoClient]
    Ivs: Type[BotoClient]
    Ivschat: Type[BotoClient]
    Kafka: Type[BotoClient]
    Kafkaconnect: Type[BotoClient]
    Kendra: Type[BotoClient]
    Kendra_Ranking: Type[BotoClient]
    Keyspaces: Type[BotoClient]
    Kinesis: Type[BotoClient]
    Kinesis_Video_Archived_Media: Type[BotoClient]
    Kinesis_Video_Media: Type[BotoClient]
    Kinesis_Video_Signaling: Type[BotoClient]
    Kinesis_Video_Webrtc_Storage: Type[BotoClient]
    KinesisAnalytics: Type[BotoClient]
    KinesisAnalyticsv2: Type[BotoClient]
    Kinesisvideo: Type[BotoClient]
    Kms: Type[BotoClient]
    Lakeformation: Type[BotoClient]
    # Lambda Is A Key-Word, Underscore Is Ignored.
    Lambda_: Type[BotoClient]
    Lex_Models: Type[BotoClient]
    Lex_Runtime: Type[BotoClient]
    Lexv2_Models: Type[BotoClient]
    Lexv2_Runtime: Type[BotoClient]
    License_Manager: Type[BotoClient]
    License_Manager_Linux_Subscriptions: Type[BotoClient]
    License_Manager_User_Subscriptions: Type[BotoClient]
    Lightsail: Type[BotoClient]
    Location: Type[BotoClient]
    Logs: Type[BotoClient]
    LookoutEquipment: Type[BotoClient]
    LookoutMetrics: Type[BotoClient]
    LookoutVision: Type[BotoClient]
    M2: Type[BotoClient]
    MachineLearning: Type[BotoClient]
    Macie: Type[BotoClient]
    Macie2: Type[BotoClient]
    ManagedBlockchain: Type[BotoClient]
    MarketPlace_Catalog: Type[BotoClient]
    MarketPlace_Entitlement: Type[BotoClient]
    MarketPlacecommerceanalytics: Type[BotoClient]
    MediaConnect: Type[BotoClient]
    MediaConvert: Type[BotoClient]
    MediaLive: Type[BotoClient]
    MediaPackage: Type[BotoClient]
    MediaPackage_Vod: Type[BotoClient]
    MediaStore: Type[BotoClient]
    MediaStore_Data: Type[BotoClient]
    MediaTailor: Type[BotoClient]
    MemoryDb: Type[BotoClient]
    MeteringMarketplace: Type[BotoClient]
    Mgh: Type[BotoClient]
    Mgn: Type[BotoClient]
    Migration_Hub_Refactor_Spaces: Type[BotoClient]
    MigrationHub_Config: Type[BotoClient]
    MigrationHubOrchestrator: Type[BotoClient]
    MigrationHubStrategy: Type[BotoClient]
    Mobile: Type[BotoClient]
    Mq: Type[BotoClient]
    Mturk: Type[BotoClient]
    Mwaa: Type[BotoClient]
    Neptune: Type[BotoClient]
    Network_Firewall: Type[BotoClient]
    Networkmanager: Type[BotoClient]
    Nimble: Type[BotoClient]
    Oam: Type[BotoClient]
    Omics: Type[BotoClient]
    Opensearch: Type[BotoClient]
    OpensearchServerless: Type[BotoClient]
    Opsworks: Type[BotoClient]
    Opsworkscm: Type[BotoClient]
    Organizations: Type[BotoClient]
    Outposts: Type[BotoClient]
    Panorama: Type[BotoClient]
    Personalize: Type[BotoClient]
    Personalize_Events: Type[BotoClient]
    Personalize_Runtime: Type[BotoClient]
    Pi: Type[BotoClient]
    Pinpoint: Type[BotoClient]
    Pinpoint_Email: Type[BotoClient]
    Pinpoint_Sms_Voice: Type[BotoClient]
    Pinpoint_Sms_Voice_V2: Type[BotoClient]
    Pipes: Type[BotoClient]
    Polly: Type[BotoClient]
    Pricing: Type[BotoClient]
    Privatenetworks: Type[BotoClient]
    Proton: Type[BotoClient]
    Qldb: Type[BotoClient]
    Qldb_Session: Type[BotoClient]
    Quicksight: Type[BotoClient]
    Ram: Type[BotoClient]
    Rbin: Type[BotoClient]
    Rds: Type[BotoClient]
    Rds_Data: Type[BotoClient]
    Redshift: Type[BotoClient]
    Redshift_Data: Type[BotoClient]
    Redshift_Serverless: Type[BotoClient]
    Rekognition: Type[BotoClient]
    Resiliencehub: Type[BotoClient]
    Resource_Explorer_2: Type[BotoClient]
    Resource_Groups: Type[BotoClient]
    ResourceGroupStaggingApi: Type[BotoClient]
    Robomaker: Type[BotoClient]
    Rolesanywhere: Type[BotoClient]
    Route53: Type[BotoClient]
    Route53_Recovery_Cluster: Type[BotoClient]
    Route53_Recovery_Control_Config: Type[BotoClient]
    Route53_Recovery_Readiness: Type[BotoClient]
    Route53Domains: Type[BotoClient]
    Route53Resolver: Type[BotoClient]
    Rum: Type[BotoClient]
    S3: Type[BotoClient]
    S3Control: Type[BotoClient]
    S3Outposts: Type[BotoClient]
    Sagemaker: Type[BotoClient]
    Sagemaker_A2I_Runtime: Type[BotoClient]
    Sagemaker_Edge: Type[BotoClient]
    Sagemaker_Featurestore_Runtime: Type[BotoClient]
    Sagemaker_Geospatial: Type[BotoClient]
    Sagemaker_Metrics: Type[BotoClient]
    Sagemaker_Runtime: Type[BotoClient]
    SavingsPlans: Type[BotoClient]
    Scheduler: Type[BotoClient]
    Schemas: Type[BotoClient]
    Sdb: Type[BotoClient]
    Secretsmanager: Type[BotoClient]
    Securityhub: Type[BotoClient]
    Securitylake: Type[BotoClient]
    Serverlessrepo: Type[BotoClient]
    Service_Quotas: Type[BotoClient]
    ServiceCatalog: Type[BotoClient]
    ServiceCatalog_Appregistry: Type[BotoClient]
    ServiceDiscovery: Type[BotoClient]
    Ses: Type[BotoClient]
    Sesv2: Type[BotoClient]
    Shield: Type[BotoClient]
    Signer: Type[BotoClient]
    Simspaceweaver: Type[BotoClient]
    Sms: Type[BotoClient]
    Sms_Voice: Type[BotoClient]
    Snow_Device_Management: Type[BotoClient]
    Snowball: Type[BotoClient]
    Sns: Type[BotoClient]
    Sqs: Type[BotoClient]
    Ssm: Type[BotoClient]
    Ssm_Contacts: Type[BotoClient]
    Ssm_Incidents: Type[BotoClient]
    Ssm_Sap: Type[BotoClient]
    Sso: Type[BotoClient]
    Sso_Admin: Type[BotoClient]
    Sso_Oidc: Type[BotoClient]
    StepFunctions: Type[BotoClient]
    StorageGateway: Type[BotoClient]
    Sts: Type[BotoClient]
    Support: Type[BotoClient]
    Support_App: Type[BotoClient]
    Swf: Type[BotoClient]
    Synthetics: Type[BotoClient]
    Textract: Type[BotoClient]
    Timestream_Query: Type[BotoClient]
    Timestream_Write: Type[BotoClient]
    Transcribe: Type[BotoClient]
    Transfer: Type[BotoClient]
    Translate: Type[BotoClient]
    Voice_Id: Type[BotoClient]
    Waf: Type[BotoClient]
    Waf_Regional: Type[BotoClient]
    Wafv2: Type[BotoClient]
    WellArchitected: Type[BotoClient]
    Wisdom: Type[BotoClient]
    Workdocs: Type[BotoClient]
    Worklink: Type[BotoClient]
    Workmail: Type[BotoClient]
    WorkmailMessageFlow: Type[BotoClient]
    Workspaces: Type[BotoClient]
    Workspaces_Web: Type[BotoClient]
    Xray: Type[BotoClient]

    # These annotations are only for IDE-type-completion;
    # any client boto supports will work regardless (even if not listed below).
    #
    # These are the boto client objects (start with lower-case letter)
    accessanalyzer: Any
    account: Any
    acm: Any
    acm_pca: Any
    alexaforbusiness: Any
    amp: Any
    amplify: Any
    amplifybackend: Any
    amplifyuibuilder: Any
    apigateway: Any
    apigatewaymanagementapi: Any
    apigatewayv2: Any
    appconfig: Any
    appconfigdata: Any
    appflow: Any
    appintegrations: Any
    application_autoscaling: Any
    application_insights: Any
    applicationcostprofiler: Any
    appmesh: Any
    apprunner: Any
    appstream: Any
    appsync: Any
    arc_zonal_shift: Any
    athena: Any
    auditmanager: Any
    autoscaling: Any
    autoscaling_plans: Any
    backup: Any
    backup_gateway: Any
    backupstorage: Any
    batch: Any
    billingconductor: Any
    braket: Any
    budgets: Any
    ce: Any
    chime: Any
    chime_sdk_identity: Any
    chime_sdk_media_pipelines: Any
    chime_sdk_meetings: Any
    chime_sdk_messaging: Any
    chime_sdk_voice: Any
    cleanrooms: Any
    cloud9: Any
    cloudcontrol: Any
    clouddirectory: Any
    cloudformation: Any
    cloudfront: Any
    cloudhsm: Any
    cloudhsmv2: Any
    cloudsearch: Any
    cloudsearchdomain: Any
    cloudtrail: Any
    cloudtrail_data: Any
    cloudwatch: Any
    codeartifact: Any
    codebuild: Any
    codecatalyst: Any
    codecommit: Any
    codedeploy: Any
    codeguru_reviewer: Any
    codeguruprofiler: Any
    codepipeline: Any
    codestar: Any
    codestar_connections: Any
    codestar_notifications: Any
    cognito_identity: Any
    cognito_idp: Any
    cognito_sync: Any
    comprehend: Any
    comprehendmedical: Any
    compute_optimizer: Any
    config: Any
    connect: Any
    connect_contact_lens: Any
    connectcampaigns: Any
    connectcases: Any
    connectparticipant: Any
    controltower: Any
    cur: Any
    customer_profiles: Any
    databrew: Any
    dataexchange: Any
    datapipeline: Any
    datasync: Any
    dax: Any
    detective: Any
    devicefarm: Any
    devops_guru: Any
    directconnect: Any
    discovery: Any
    dlm: Any
    dms: Any
    docdb: Any
    docdb_elastic: Any
    drs: Any
    ds: Any
    dynamodb: Any
    dynamodbstreams: Any
    ebs: Any
    ec2: Any
    ec2_instance_connect: Any
    ecr: Any
    ecr_public: Any
    ecs: Any
    efs: Any
    eks: Any
    elastic_inference: Any
    elasticache: Any
    elasticbeanstalk: Any
    elastictranscoder: Any
    elb: Any
    elbv2: Any
    emr: Any
    emr_containers: Any
    emr_serverless: Any
    es: Any
    events: Any
    evidently: Any
    finspace: Any
    finspace_data: Any
    firehose: Any
    fis: Any
    fms: Any
    forecast: Any
    forecastquery: Any
    frauddetector: Any
    fsx: Any
    gamelift: Any
    gamesparks: Any
    glacier: Any
    globalaccelerator: Any
    glue: Any
    grafana: Any
    greengrass: Any
    greengrassv2: Any
    groundstation: Any
    guardduty: Any
    health: Any
    healthlake: Any
    honeycode: Any
    iam: Any
    identitystore: Any
    imagebuilder: Any
    importexport: Any
    inspector: Any
    inspector2: Any
    iot: Any
    iot_data: Any
    iot_jobs_data: Any
    iot_roborunner: Any
    iot1click_devices: Any
    iot1click_projects: Any
    iotanalytics: Any
    iotdeviceadvisor: Any
    iotevents: Any
    iotevents_data: Any
    iotfleethub: Any
    iotfleetwise: Any
    iotsecuretunneling: Any
    iotsitewise: Any
    iotthingsgraph: Any
    iottwinmaker: Any
    iotwireless: Any
    ivs: Any
    ivschat: Any
    kafka: Any
    kafkaconnect: Any
    kendra: Any
    kendra_ranking: Any
    keyspaces: Any
    kinesis: Any
    kinesis_video_archived_media: Any
    kinesis_video_media: Any
    kinesis_video_signaling: Any
    kinesis_video_webrtc_storage: Any
    kinesisanalytics: Any
    kinesisanalyticsv2: Any
    kinesisvideo: Any
    kms: Any
    lakeformation: Any
    # Lambda is a key-word, underscore is ignored.
    lambda_: Any
    lex_models: Any
    lex_runtime: Any
    lexv2_models: Any
    lexv2_runtime: Any
    license_manager: Any
    license_manager_linux_subscriptions: Any
    license_manager_user_subscriptions: Any
    lightsail: Any
    location: Any
    logs: Any
    lookoutequipment: Any
    lookoutmetrics: Any
    lookoutvision: Any
    m2: Any
    machinelearning: Any
    macie: Any
    macie2: Any
    managedblockchain: Any
    marketplace_catalog: Any
    marketplace_entitlement: Any
    marketplacecommerceanalytics: Any
    mediaconnect: Any
    mediaconvert: Any
    medialive: Any
    mediapackage: Any
    mediapackage_vod: Any
    mediastore: Any
    mediastore_data: Any
    mediatailor: Any
    memorydb: Any
    meteringmarketplace: Any
    mgh: Any
    mgn: Any
    migration_hub_refactor_spaces: Any
    migrationhub_config: Any
    migrationhuborchestrator: Any
    migrationhubstrategy: Any
    mobile: Any
    mq: Any
    mturk: Any
    mwaa: Any
    neptune: Any
    network_firewall: Any
    networkmanager: Any
    nimble: Any
    oam: Any
    omics: Any
    opensearch: Any
    opensearchserverless: Any
    opsworks: Any
    opsworkscm: Any
    organizations: Any
    outposts: Any
    panorama: Any
    personalize: Any
    personalize_events: Any
    personalize_runtime: Any
    pi: Any
    pinpoint: Any
    pinpoint_email: Any
    pinpoint_sms_voice: Any
    pinpoint_sms_voice_v2: Any
    pipes: Any
    polly: Any
    pricing: Any
    privatenetworks: Any
    proton: Any
    qldb: Any
    qldb_session: Any
    quicksight: Any
    ram: Any
    rbin: Any
    rds: Any
    rds_data: Any
    redshift: Any
    redshift_data: Any
    redshift_serverless: Any
    rekognition: Any
    resiliencehub: Any
    resource_explorer_2: Any
    resource_groups: Any
    resourcegroupstaggingapi: Any
    robomaker: Any
    rolesanywhere: Any
    route53: Any
    route53_recovery_cluster: Any
    route53_recovery_control_config: Any
    route53_recovery_readiness: Any
    route53domains: Any
    route53resolver: Any
    rum: Any
    s3: Any
    s3control: Any
    s3outposts: Any
    sagemaker: Any
    sagemaker_a2i_runtime: Any
    sagemaker_edge: Any
    sagemaker_featurestore_runtime: Any
    sagemaker_geospatial: Any
    sagemaker_metrics: Any
    sagemaker_runtime: Any
    savingsplans: Any
    scheduler: Any
    schemas: Any
    sdb: Any
    secretsmanager: Any
    securityhub: Any
    securitylake: Any
    serverlessrepo: Any
    service_quotas: Any
    servicecatalog: Any
    servicecatalog_appregistry: Any
    servicediscovery: Any
    ses: Any
    sesv2: Any
    shield: Any
    signer: Any
    simspaceweaver: Any
    sms: Any
    sms_voice: Any
    snow_device_management: Any
    snowball: Any
    sns: Any
    sqs: Any
    ssm: Any
    ssm_contacts: Any
    ssm_incidents: Any
    ssm_sap: Any
    sso: Any
    sso_admin: Any
    sso_oidc: Any
    stepfunctions: Any
    storagegateway: Any
    sts: Any
    support: Any
    support_app: Any
    swf: Any
    synthetics: Any
    textract: Any
    timestream_query: Any
    timestream_write: Any
    transcribe: Any
    transfer: Any
    translate: Any
    voice_id: Any
    waf: Any
    waf_regional: Any
    wafv2: Any
    wellarchitected: Any
    wisdom: Any
    workdocs: Any
    worklink: Any
    workmail: Any
    workmailmessageflow: Any
    workspaces: Any
    workspaces_web: Any
    xray: Any


class BotoResources(_Loader, boto_dependency_class=BotoResource):
    &#34;&#34;&#34;
    When you get an attribute off of me, I&#39;ll attempt to ask the boto3 library to allocate
    a resource of the same type, and then store itself, so I return the same resource again
    in the future.

    Right now, we will lazily allocate a boto3 resource per-thread, and we will use the
    per-thread shared boto3 session resource to do it (ie: `_BotoSession.session`).

    You can also easily import and use the `boto_resources` proxy object
    (defined at top module-level).

    You can use `boto_resources` exactly the same as using `BotoResources.grab()`,
    making it more convenient to use since you can directly import `boto_resources`.

    &gt;&gt;&gt; from xboto import boto_resources
    &gt;&gt;&gt; # Showing here how you could use it to get a Table resource:
    &gt;&gt;&gt; table = boto_resources.dynamodb.Table(&#34;some-table&#34;)

    If you have an aws resource that uses a `-` for it&#39;s name, you can use an `_` (underscore)
    instead.
    All underscores are changed to a `-` when looking up the aws resource.
    You can also directly use the `xboto.dependencies.BotoResources.load` method, and use a `-`
    there.
    &#34;&#34;&#34;

    def _lookup(self, module, **kwargs):
        return BotoResource.get_dependency_cls(module).grab().boto_resource

    # These annotations are only for IDE-type-completion;
    # any client boto supports will work regardless (even if not listed below).
    #
    # These are the xyn-resource `Resource` types/classes; ie: BotoResource subclasses
    # (start with upper-case letter):
    DynamoDB: Type[BotoResource]
    CloudFormation: Type[BotoResource]
    CloudWatch: Type[BotoResource]
    Ec2: Type[BotoResource]
    Glacier: Type[BotoResource]
    Iam: Type[BotoResource]
    OpsWorks: Type[BotoResource]
    S3: Type[BotoResource]
    Ns: Type[BotoResource]
    Sqs: Type[BotoResource]

    # These annotations are only for IDE-type-completion;
    # any client boto supports will work regardless (even if not listed below).
    #
    # These are the boto resource objects (start with lower-case letter):
    dynamodb: Any
    cloudformation: Any
    cloudwatch: Any
    ec2: Any
    glacier: Any
    iam: Any
    opsworks: Any
    s3: Any
    ns: Any
    sqs: Any


boto_clients = BotoClients.proxy()
&#34;&#34;&#34; You can import this and then ask it for clients via attributes.

    Example:

    &gt;&gt;&gt; from xboto import boto_clients
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Get the ssm client (ask for it each time), then get it&#39;s paginator.
    &gt;&gt;&gt; boto_clients.ssm.get_paginator(...)

    You can also directly import a client like so:

    &gt;&gt;&gt; from xboto.client import ssm
    &gt;&gt;&gt;
    &gt;&gt;&gt; # You can just use it directly anytime you need too:
    &gt;&gt;&gt; ssm.get_paginator()

    Or import top-level object only:

    &gt;&gt; import xboto
    &gt;&gt;
    &gt;&gt;&gt; # You can just use any client you want:
    &gt;&gt;&gt; xboto.client.ssm.get_paginator()
&#34;&#34;&#34;

boto_resources = BotoResources.proxy()
&#34;&#34;&#34; You can import this and then ask it for clients via attributes.

    Example:

    &gt;&gt;&gt; from xboto import boto_resources FINISH HERE!!!!! ****
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Get the ssm client (ask for it each time), then get it&#39;s paginator.
    &gt;&gt;&gt; boto_resources.dynamodb.create_table()

    You can also directly import a client like so:

    &gt;&gt;&gt; from xboto.resource import dynamodb
    &gt;&gt;&gt;
    &gt;&gt;&gt; # You can just use it directly anytime you need too:
    &gt;&gt;&gt; dynamodb.create_table()

    Or import top-level object only:

    &gt;&gt; import xboto
    &gt;&gt;
    &gt;&gt;&gt; # You can just use any client you want:
    &gt;&gt;&gt; xboto.resource.dynamodb.create_table()
&#34;&#34;&#34;</code></pre>
</details>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="xboto.dependencies.boto_clients"><code class="name">var <span class="ident">boto_clients</span></code></dt>
<dd>
<div class="desc"><p>You can import this and then ask it for clients via attributes.</p>
<p>Example:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xboto import boto_clients
&gt;&gt;&gt;
&gt;&gt;&gt; # Get the ssm client (ask for it each time), then get it's paginator.
&gt;&gt;&gt; boto_clients.ssm.get_paginator(...)
</code></pre>
<p>You can also directly import a client like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xboto.client import ssm
&gt;&gt;&gt;
&gt;&gt;&gt; # You can just use it directly anytime you need too:
&gt;&gt;&gt; ssm.get_paginator()
</code></pre>
<p>Or import top-level object only:</p>
<blockquote>
<blockquote>
<p>import xboto
</p>
</blockquote>
</blockquote>
<pre><code class="language-python-repl">&gt;&gt;&gt; # You can just use any client you want:
&gt;&gt;&gt; xboto.client.ssm.get_paginator()
</code></pre></div>
</dd>
<dt id="xboto.dependencies.boto_resources"><code class="name">var <span class="ident">boto_resources</span></code></dt>
<dd>
<div class="desc"><p>You can import this and then ask it for clients via attributes.</p>
<p>Example:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xboto import boto_resources FINISH HERE!!!!! ****
&gt;&gt;&gt;
&gt;&gt;&gt; # Get the ssm client (ask for it each time), then get it's paginator.
&gt;&gt;&gt; boto_resources.dynamodb.create_table()
</code></pre>
<p>You can also directly import a client like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xboto.resource import dynamodb
&gt;&gt;&gt;
&gt;&gt;&gt; # You can just use it directly anytime you need too:
&gt;&gt;&gt; dynamodb.create_table()
</code></pre>
<p>Or import top-level object only:</p>
<blockquote>
<blockquote>
<p>import xboto
</p>
</blockquote>
</blockquote>
<pre><code class="language-python-repl">&gt;&gt;&gt; # You can just use any client you want:
&gt;&gt;&gt; xboto.resource.dynamodb.create_table()
</code></pre></div>
</dd>
<dt id="xboto.dependencies.boto_session"><code class="name">var <span class="ident">boto_session</span></code></dt>
<dd>
<div class="desc"><p>You can use this as the current 'boto' session object.
<code>_Loader</code> subclasses use this right now (see below).</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="xboto.dependencies.BotoClient"><code class="flex name class">
<span>class <span class="ident">BotoClient</span></span>
<span>(</span><span>region_name=None, api_version=None, use_ssl=None, verify=None, endpoint_url=None, aws_access_key_id=None, aws_secret_access_key=None, aws_session_token=None, config=None, **boto_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p>
<p>You can specify any of the boto client/resource args, the known ones have been
specififed and documented out.</p>
<p>If there are ones in the future that are new or we don't know about, you can
still specify them, they will be passed to us in <code>boto_kwargs</code>, which will be
used as addtional kwargs when creating new boto client/resource.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>region_name</code></strong></dt>
<dd>The name of the region associated with the client. A client is associated
with a single region.</dd>
<dt><strong><code>api_version</code></strong></dt>
<dd>The API version to use. By default, botocore will use the latest API
version when creating a client.You only need to specify this parameter if you want
to use a previous API version of the client.</dd>
<dt><strong><code>use_ssl</code></strong></dt>
<dd>Whether or not to use SSL. By default, SSL is used. Note that not all
services support non-ssl connections.</dd>
<dt><strong><code>verify</code></strong></dt>
<dd>
<p>Whether or not to verify SSL certificates. By default SSL certificates are
verified. You can provide the following values:</p>
<ul>
<li>False - do not validate SSL certificates. SSL will still be used
(unless use_ssl is False), but SSL certificates will not be verified.</li>
<li>path/to/cert/bundle.pem - A filename of the CA cert bundle to uses.
You can specify this argument if you want to use a different CA cert bundle
than the one used by botocore.</li>
</ul>
</dd>
<dt><strong><code>endpoint_url</code></strong></dt>
<dd>The complete URL to use for the constructed client.
Normally, botocore will automatically construct the appropriate URL to use when
communicating with a service. You can specify a complete URL
(including the "http/https" scheme) to override this behavior.
If this value is provided, then use_ssl is ignored.</dd>
<dt><strong><code>aws_access_key_id</code></strong></dt>
<dd>The access key to use when creating the client.
This is entirely optional, and if not provided, the credentials configured for the
session will automatically be used. You only need to provide this argument if you
want to override the credentials used for this specific client.</dd>
<dt><strong><code>aws_secret_access_key</code></strong></dt>
<dd>The secret key to use when creating the client.
Same semantics as aws_access_key_id above.</dd>
<dt><strong><code>aws_session_token</code></strong></dt>
<dd>The session token to use when creating the client.
Same semantics as aws_access_key_id above.</dd>
<dt><strong><code>config</code></strong></dt>
<dd>Advanced client configuration options.
If region_name is specified in the client config, its value will take precedence
over environment variables and configuration values, but not over a region_name
value passed explicitly to the method. If user_agent_extra is specified in the
client config, it overrides the default user_agent_extra provided by the resource
API. See
<a href="https://botocore.amazonaws.com/v1/documentation/api/latest/reference/config.html">botocore config documentation</a>
for more details.</dd>
</dl>
<p>**boto_kwargs:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BotoClient(_BaseBotoClientOrResource, boto_kind=&#39;client&#39;):
    @property
    def boto_client(self):
        return self.get()

    @classmethod
    def get_dependency_cls(cls, boto_name: str) -&gt; &#39;Type[BotoClient]&#39;:
        return cls._get_dependency_cls(boto_name)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>xboto.dependencies._BaseBotoClientOrResource</li>
<li><a title="xinject.dependency.Dependency" href="../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>xboto.dependencies.AccessanalyzerClient</li>
<li>xboto.dependencies.AccountClient</li>
<li>xboto.dependencies.Acm-pcaClient</li>
<li>xboto.dependencies.AcmClient</li>
<li>xboto.dependencies.AlexaforbusinessClient</li>
<li>xboto.dependencies.AmpClient</li>
<li>xboto.dependencies.AmplifyClient</li>
<li>xboto.dependencies.AmplifybackendClient</li>
<li>xboto.dependencies.AmplifyuibuilderClient</li>
<li>xboto.dependencies.ApigatewayClient</li>
<li>xboto.dependencies.ApigatewaymanagementapiClient</li>
<li>xboto.dependencies.Apigatewayv2Client</li>
<li>xboto.dependencies.AppconfigClient</li>
<li>xboto.dependencies.AppconfigdataClient</li>
<li>xboto.dependencies.AppflowClient</li>
<li>xboto.dependencies.AppintegrationsClient</li>
<li>xboto.dependencies.Application-autoscalingClient</li>
<li>xboto.dependencies.Application-insightsClient</li>
<li>xboto.dependencies.ApplicationcostprofilerClient</li>
<li>xboto.dependencies.AppmeshClient</li>
<li>xboto.dependencies.ApprunnerClient</li>
<li>xboto.dependencies.AppstreamClient</li>
<li>xboto.dependencies.AppsyncClient</li>
<li>xboto.dependencies.Arc-zonal-shiftClient</li>
<li>xboto.dependencies.AthenaClient</li>
<li>xboto.dependencies.AuditmanagerClient</li>
<li>xboto.dependencies.Autoscaling-plansClient</li>
<li>xboto.dependencies.AutoscalingClient</li>
<li>xboto.dependencies.Backup-gatewayClient</li>
<li>xboto.dependencies.BackupClient</li>
<li>xboto.dependencies.BackupstorageClient</li>
<li>xboto.dependencies.BatchClient</li>
<li>xboto.dependencies.BillingconductorClient</li>
<li>xboto.dependencies.BraketClient</li>
<li>xboto.dependencies.BudgetsClient</li>
<li>xboto.dependencies.CeClient</li>
<li>xboto.dependencies.Chime-sdk-identityClient</li>
<li>xboto.dependencies.Chime-sdk-media-pipelinesClient</li>
<li>xboto.dependencies.Chime-sdk-meetingsClient</li>
<li>xboto.dependencies.Chime-sdk-messagingClient</li>
<li>xboto.dependencies.Chime-sdk-voiceClient</li>
<li>xboto.dependencies.ChimeClient</li>
<li>xboto.dependencies.CleanroomsClient</li>
<li>xboto.dependencies.Cloud9Client</li>
<li>xboto.dependencies.CloudcontrolClient</li>
<li>xboto.dependencies.ClouddirectoryClient</li>
<li>xboto.dependencies.CloudformationClient</li>
<li>xboto.dependencies.CloudfrontClient</li>
<li>xboto.dependencies.CloudhsmClient</li>
<li>xboto.dependencies.Cloudhsmv2Client</li>
<li>xboto.dependencies.CloudsearchClient</li>
<li>xboto.dependencies.CloudsearchdomainClient</li>
<li>xboto.dependencies.Cloudtrail-dataClient</li>
<li>xboto.dependencies.CloudtrailClient</li>
<li>xboto.dependencies.CloudwatchClient</li>
<li>xboto.dependencies.CodeartifactClient</li>
<li>xboto.dependencies.CodebuildClient</li>
<li>xboto.dependencies.CodecatalystClient</li>
<li>xboto.dependencies.CodecommitClient</li>
<li>xboto.dependencies.CodedeployClient</li>
<li>xboto.dependencies.Codeguru-reviewerClient</li>
<li>xboto.dependencies.CodeguruprofilerClient</li>
<li>xboto.dependencies.CodepipelineClient</li>
<li>xboto.dependencies.Codestar-connectionsClient</li>
<li>xboto.dependencies.Codestar-notificationsClient</li>
<li>xboto.dependencies.CodestarClient</li>
<li>xboto.dependencies.Cognito-identityClient</li>
<li>xboto.dependencies.Cognito-idpClient</li>
<li>xboto.dependencies.Cognito-syncClient</li>
<li>xboto.dependencies.ComprehendClient</li>
<li>xboto.dependencies.ComprehendmedicalClient</li>
<li>xboto.dependencies.Compute-optimizerClient</li>
<li>xboto.dependencies.ConfigClient</li>
<li>xboto.dependencies.Connect-contact-lensClient</li>
<li>xboto.dependencies.ConnectClient</li>
<li>xboto.dependencies.ConnectcampaignsClient</li>
<li>xboto.dependencies.ConnectcasesClient</li>
<li>xboto.dependencies.ConnectparticipantClient</li>
<li>xboto.dependencies.ControltowerClient</li>
<li>xboto.dependencies.CurClient</li>
<li>xboto.dependencies.Customer-profilesClient</li>
<li>xboto.dependencies.DatabrewClient</li>
<li>xboto.dependencies.DataexchangeClient</li>
<li>xboto.dependencies.DatapipelineClient</li>
<li>xboto.dependencies.DatasyncClient</li>
<li>xboto.dependencies.DaxClient</li>
<li>xboto.dependencies.DetectiveClient</li>
<li>xboto.dependencies.DevicefarmClient</li>
<li>xboto.dependencies.Devops-guruClient</li>
<li>xboto.dependencies.DirectconnectClient</li>
<li>xboto.dependencies.DiscoveryClient</li>
<li>xboto.dependencies.DlmClient</li>
<li>xboto.dependencies.DmsClient</li>
<li>xboto.dependencies.Docdb-elasticClient</li>
<li>xboto.dependencies.DocdbClient</li>
<li>xboto.dependencies.DrsClient</li>
<li>xboto.dependencies.DsClient</li>
<li>xboto.dependencies.DynamodbClient</li>
<li>xboto.dependencies.DynamodbstreamsClient</li>
<li>xboto.dependencies.EbsClient</li>
<li>xboto.dependencies.Ec2-instance-connectClient</li>
<li>xboto.dependencies.Ec2Client</li>
<li>xboto.dependencies.Ecr-publicClient</li>
<li>xboto.dependencies.EcrClient</li>
<li>xboto.dependencies.EcsClient</li>
<li>xboto.dependencies.EfsClient</li>
<li>xboto.dependencies.EksClient</li>
<li>xboto.dependencies.Elastic-inferenceClient</li>
<li>xboto.dependencies.ElasticacheClient</li>
<li>xboto.dependencies.ElasticbeanstalkClient</li>
<li>xboto.dependencies.ElastictranscoderClient</li>
<li>xboto.dependencies.ElbClient</li>
<li>xboto.dependencies.Elbv2Client</li>
<li>xboto.dependencies.Emr-containersClient</li>
<li>xboto.dependencies.Emr-serverlessClient</li>
<li>xboto.dependencies.EmrClient</li>
<li>xboto.dependencies.EsClient</li>
<li>xboto.dependencies.EventsClient</li>
<li>xboto.dependencies.EvidentlyClient</li>
<li>xboto.dependencies.Finspace-dataClient</li>
<li>xboto.dependencies.FinspaceClient</li>
<li>xboto.dependencies.FirehoseClient</li>
<li>xboto.dependencies.FisClient</li>
<li>xboto.dependencies.FmsClient</li>
<li>xboto.dependencies.ForecastClient</li>
<li>xboto.dependencies.ForecastqueryClient</li>
<li>xboto.dependencies.FrauddetectorClient</li>
<li>xboto.dependencies.FsxClient</li>
<li>xboto.dependencies.GameliftClient</li>
<li>xboto.dependencies.GamesparksClient</li>
<li>xboto.dependencies.GlacierClient</li>
<li>xboto.dependencies.GlobalacceleratorClient</li>
<li>xboto.dependencies.GlueClient</li>
<li>xboto.dependencies.GrafanaClient</li>
<li>xboto.dependencies.GreengrassClient</li>
<li>xboto.dependencies.Greengrassv2Client</li>
<li>xboto.dependencies.GroundstationClient</li>
<li>xboto.dependencies.GuarddutyClient</li>
<li>xboto.dependencies.HealthClient</li>
<li>xboto.dependencies.HealthlakeClient</li>
<li>xboto.dependencies.HoneycodeClient</li>
<li>xboto.dependencies.IamClient</li>
<li>xboto.dependencies.IdentitystoreClient</li>
<li>xboto.dependencies.ImagebuilderClient</li>
<li>xboto.dependencies.ImportexportClient</li>
<li>xboto.dependencies.Inspector2Client</li>
<li>xboto.dependencies.InspectorClient</li>
<li>xboto.dependencies.Iot-dataClient</li>
<li>xboto.dependencies.Iot-jobs-dataClient</li>
<li>xboto.dependencies.Iot-roborunnerClient</li>
<li>xboto.dependencies.Iot1click-devicesClient</li>
<li>xboto.dependencies.Iot1click-projectsClient</li>
<li>xboto.dependencies.IotClient</li>
<li>xboto.dependencies.IotanalyticsClient</li>
<li>xboto.dependencies.IotdeviceadvisorClient</li>
<li>xboto.dependencies.Iotevents-dataClient</li>
<li>xboto.dependencies.IoteventsClient</li>
<li>xboto.dependencies.IotfleethubClient</li>
<li>xboto.dependencies.IotfleetwiseClient</li>
<li>xboto.dependencies.IotsecuretunnelingClient</li>
<li>xboto.dependencies.IotsitewiseClient</li>
<li>xboto.dependencies.IotthingsgraphClient</li>
<li>xboto.dependencies.IottwinmakerClient</li>
<li>xboto.dependencies.IotwirelessClient</li>
<li>xboto.dependencies.IvsClient</li>
<li>xboto.dependencies.IvschatClient</li>
<li>xboto.dependencies.KafkaClient</li>
<li>xboto.dependencies.KafkaconnectClient</li>
<li>xboto.dependencies.Kendra-rankingClient</li>
<li>xboto.dependencies.KendraClient</li>
<li>xboto.dependencies.KeyspacesClient</li>
<li>xboto.dependencies.Kinesis-video-archived-mediaClient</li>
<li>xboto.dependencies.Kinesis-video-mediaClient</li>
<li>xboto.dependencies.Kinesis-video-signalingClient</li>
<li>xboto.dependencies.Kinesis-video-webrtc-storageClient</li>
<li>xboto.dependencies.KinesisClient</li>
<li>xboto.dependencies.KinesisanalyticsClient</li>
<li>xboto.dependencies.Kinesisanalyticsv2Client</li>
<li>xboto.dependencies.KinesisvideoClient</li>
<li>xboto.dependencies.KmsClient</li>
<li>xboto.dependencies.LakeformationClient</li>
<li>xboto.dependencies.LambdaClient</li>
<li>xboto.dependencies.Lex-modelsClient</li>
<li>xboto.dependencies.Lex-runtimeClient</li>
<li>xboto.dependencies.Lexv2-modelsClient</li>
<li>xboto.dependencies.Lexv2-runtimeClient</li>
<li>xboto.dependencies.License-manager-linux-subscriptionsClient</li>
<li>xboto.dependencies.License-manager-user-subscriptionsClient</li>
<li>xboto.dependencies.License-managerClient</li>
<li>xboto.dependencies.LightsailClient</li>
<li>xboto.dependencies.LocationClient</li>
<li>xboto.dependencies.LogsClient</li>
<li>xboto.dependencies.LookoutequipmentClient</li>
<li>xboto.dependencies.LookoutmetricsClient</li>
<li>xboto.dependencies.LookoutvisionClient</li>
<li>xboto.dependencies.M2Client</li>
<li>xboto.dependencies.MachinelearningClient</li>
<li>xboto.dependencies.Macie2Client</li>
<li>xboto.dependencies.MacieClient</li>
<li>xboto.dependencies.ManagedblockchainClient</li>
<li>xboto.dependencies.Marketplace-catalogClient</li>
<li>xboto.dependencies.Marketplace-entitlementClient</li>
<li>xboto.dependencies.MarketplacecommerceanalyticsClient</li>
<li>xboto.dependencies.MediaconnectClient</li>
<li>xboto.dependencies.MediaconvertClient</li>
<li>xboto.dependencies.MedialiveClient</li>
<li>xboto.dependencies.Mediapackage-vodClient</li>
<li>xboto.dependencies.MediapackageClient</li>
<li>xboto.dependencies.Mediastore-dataClient</li>
<li>xboto.dependencies.MediastoreClient</li>
<li>xboto.dependencies.MediatailorClient</li>
<li>xboto.dependencies.MemorydbClient</li>
<li>xboto.dependencies.MeteringmarketplaceClient</li>
<li>xboto.dependencies.MghClient</li>
<li>xboto.dependencies.MgnClient</li>
<li>xboto.dependencies.Migration-hub-refactor-spacesClient</li>
<li>xboto.dependencies.Migrationhub-configClient</li>
<li>xboto.dependencies.MigrationhuborchestratorClient</li>
<li>xboto.dependencies.MigrationhubstrategyClient</li>
<li>xboto.dependencies.MobileClient</li>
<li>xboto.dependencies.MqClient</li>
<li>xboto.dependencies.MturkClient</li>
<li>xboto.dependencies.MwaaClient</li>
<li>xboto.dependencies.NeptuneClient</li>
<li>xboto.dependencies.Network-firewallClient</li>
<li>xboto.dependencies.NetworkmanagerClient</li>
<li>xboto.dependencies.NimbleClient</li>
<li>xboto.dependencies.OamClient</li>
<li>xboto.dependencies.OmicsClient</li>
<li>xboto.dependencies.OpensearchClient</li>
<li>xboto.dependencies.OpensearchserverlessClient</li>
<li>xboto.dependencies.OpsworksClient</li>
<li>xboto.dependencies.OpsworkscmClient</li>
<li>xboto.dependencies.OrganizationsClient</li>
<li>xboto.dependencies.OutpostsClient</li>
<li>xboto.dependencies.PanoramaClient</li>
<li>xboto.dependencies.Personalize-eventsClient</li>
<li>xboto.dependencies.Personalize-runtimeClient</li>
<li>xboto.dependencies.PersonalizeClient</li>
<li>xboto.dependencies.PiClient</li>
<li>xboto.dependencies.Pinpoint-emailClient</li>
<li>xboto.dependencies.Pinpoint-sms-voice-v2Client</li>
<li>xboto.dependencies.Pinpoint-sms-voiceClient</li>
<li>xboto.dependencies.PinpointClient</li>
<li>xboto.dependencies.PipesClient</li>
<li>xboto.dependencies.PollyClient</li>
<li>xboto.dependencies.PricingClient</li>
<li>xboto.dependencies.PrivatenetworksClient</li>
<li>xboto.dependencies.ProtonClient</li>
<li>xboto.dependencies.Qldb-sessionClient</li>
<li>xboto.dependencies.QldbClient</li>
<li>xboto.dependencies.QuicksightClient</li>
<li>xboto.dependencies.RamClient</li>
<li>xboto.dependencies.RbinClient</li>
<li>xboto.dependencies.Rds-dataClient</li>
<li>xboto.dependencies.RdsClient</li>
<li>xboto.dependencies.Redshift-dataClient</li>
<li>xboto.dependencies.Redshift-serverlessClient</li>
<li>xboto.dependencies.RedshiftClient</li>
<li>xboto.dependencies.RekognitionClient</li>
<li>xboto.dependencies.ResiliencehubClient</li>
<li>xboto.dependencies.Resource-explorer-2Client</li>
<li>xboto.dependencies.Resource-groupsClient</li>
<li>xboto.dependencies.ResourcegroupstaggingapiClient</li>
<li>xboto.dependencies.RobomakerClient</li>
<li>xboto.dependencies.RolesanywhereClient</li>
<li>xboto.dependencies.Route53-recovery-clusterClient</li>
<li>xboto.dependencies.Route53-recovery-control-configClient</li>
<li>xboto.dependencies.Route53-recovery-readinessClient</li>
<li>xboto.dependencies.Route53Client</li>
<li>xboto.dependencies.Route53domainsClient</li>
<li>xboto.dependencies.Route53resolverClient</li>
<li>xboto.dependencies.RumClient</li>
<li>xboto.dependencies.S3Client</li>
<li>xboto.dependencies.S3controlClient</li>
<li>xboto.dependencies.S3outpostsClient</li>
<li>xboto.dependencies.Sagemaker-a2i-runtimeClient</li>
<li>xboto.dependencies.Sagemaker-edgeClient</li>
<li>xboto.dependencies.Sagemaker-featurestore-runtimeClient</li>
<li>xboto.dependencies.Sagemaker-geospatialClient</li>
<li>xboto.dependencies.Sagemaker-metricsClient</li>
<li>xboto.dependencies.Sagemaker-runtimeClient</li>
<li>xboto.dependencies.SagemakerClient</li>
<li>xboto.dependencies.SavingsplansClient</li>
<li>xboto.dependencies.SchedulerClient</li>
<li>xboto.dependencies.SchemasClient</li>
<li>xboto.dependencies.SdbClient</li>
<li>xboto.dependencies.SecretsmanagerClient</li>
<li>xboto.dependencies.SecurityhubClient</li>
<li>xboto.dependencies.SecuritylakeClient</li>
<li>xboto.dependencies.ServerlessrepoClient</li>
<li>xboto.dependencies.Service-quotasClient</li>
<li>xboto.dependencies.Servicecatalog-appregistryClient</li>
<li>xboto.dependencies.ServicecatalogClient</li>
<li>xboto.dependencies.ServicediscoveryClient</li>
<li>xboto.dependencies.SesClient</li>
<li>xboto.dependencies.Sesv2Client</li>
<li>xboto.dependencies.ShieldClient</li>
<li>xboto.dependencies.SignerClient</li>
<li>xboto.dependencies.SimspaceweaverClient</li>
<li>xboto.dependencies.Sms-voiceClient</li>
<li>xboto.dependencies.SmsClient</li>
<li>xboto.dependencies.Snow-device-managementClient</li>
<li>xboto.dependencies.SnowballClient</li>
<li>xboto.dependencies.SnsClient</li>
<li>xboto.dependencies.SqsClient</li>
<li>xboto.dependencies.Ssm-contactsClient</li>
<li>xboto.dependencies.Ssm-incidentsClient</li>
<li>xboto.dependencies.Ssm-sapClient</li>
<li>xboto.dependencies.SsmClient</li>
<li>xboto.dependencies.Sso-adminClient</li>
<li>xboto.dependencies.Sso-oidcClient</li>
<li>xboto.dependencies.SsoClient</li>
<li>xboto.dependencies.StepfunctionsClient</li>
<li>xboto.dependencies.StoragegatewayClient</li>
<li>xboto.dependencies.StsClient</li>
<li>xboto.dependencies.Support-appClient</li>
<li>xboto.dependencies.SupportClient</li>
<li>xboto.dependencies.SwfClient</li>
<li>xboto.dependencies.SyntheticsClient</li>
<li>xboto.dependencies.TextractClient</li>
<li>xboto.dependencies.Timestream-queryClient</li>
<li>xboto.dependencies.Timestream-writeClient</li>
<li>xboto.dependencies.TranscribeClient</li>
<li>xboto.dependencies.TransferClient</li>
<li>xboto.dependencies.TranslateClient</li>
<li>xboto.dependencies.Voice-idClient</li>
<li>xboto.dependencies.Waf-regionalClient</li>
<li>xboto.dependencies.WafClient</li>
<li>xboto.dependencies.Wafv2Client</li>
<li>xboto.dependencies.WellarchitectedClient</li>
<li>xboto.dependencies.WisdomClient</li>
<li>xboto.dependencies.WorkdocsClient</li>
<li>xboto.dependencies.WorklinkClient</li>
<li>xboto.dependencies.WorkmailClient</li>
<li>xboto.dependencies.WorkmailmessageflowClient</li>
<li>xboto.dependencies.Workspaces-webClient</li>
<li>xboto.dependencies.WorkspacesClient</li>
<li>xboto.dependencies.XrayClient</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="xboto.dependencies.BotoClient.__init_subclass__"><code class="name flex">
<span>def <span class="ident">__init_subclass__</span></span>(<span>thread_sharable=Default, attributes_to_skip_while_copying:Â Optional[Iterable[str]]Â =Â Default, **kwargs)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xinject.dependency.Dependency" href="../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></code>.<code><a title="xinject.dependency.Dependency.__init_subclass__" href="../xinject/dependency.html#xinject.dependency.Dependency.__init_subclass__">__init_subclass__</a></code>
</p>
<div class="desc inherited"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>thread_sharable</code></strong></dt>
<dd>If <code>False</code>: While a dependency is lazily auto-created, we will
ensure we do it per-thread, and not make it visible â€¦</dd>
</dl></div>
</dd>
<dt id="xboto.dependencies.BotoClient.get_dependency_cls"><code class="name flex">
<span>def <span class="ident">get_dependency_cls</span></span>(<span>boto_name:Â str) â€‘>Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def get_dependency_cls(cls, boto_name: str) -&gt; &#39;Type[BotoClient]&#39;:
    return cls._get_dependency_cls(boto_name)</code></pre>
</details>
</dd>
<dt id="xboto.dependencies.BotoClient.grab"><code class="name flex">
<span>def <span class="ident">grab</span></span>(<span>) â€‘>Â ~T</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xinject.dependency.Dependency" href="../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></code>.<code><a title="xinject.dependency.Dependency.grab" href="../xinject/dependency.html#xinject.dependency.Dependency.grab">grab</a></code>
</p>
<div class="desc inherited"><p>Gets a potentially shared dependency from the current <code>udpend.context.XContext</code> â€¦</p></div>
</dd>
<dt id="xboto.dependencies.BotoClient.proxy"><code class="name flex">
<span>def <span class="ident">proxy</span></span>(<span>) â€‘>Â ~R</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xinject.dependency.Dependency" href="../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></code>.<code><a title="xinject.dependency.Dependency.proxy" href="../xinject/dependency.html#xinject.dependency.Dependency.proxy">proxy</a></code>
</p>
<div class="desc inherited"><p>Returns a proxy-object, that when and attribute is asked for, it will
proxy it to the current object of <code>cls</code> â€¦</p></div>
</dd>
<dt id="xboto.dependencies.BotoClient.proxy_attribute"><code class="name flex">
<span>def <span class="ident">proxy_attribute</span></span>(<span>attribute_name:Â str) â€‘>Â Any</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xinject.dependency.Dependency" href="../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></code>.<code><a title="xinject.dependency.Dependency.proxy_attribute" href="../xinject/dependency.html#xinject.dependency.Dependency.proxy_attribute">proxy_attribute</a></code>
</p>
<div class="desc inherited"><p>Returns a proxy-object, that when and attribute is asked for, it will
proxy it to the current attribute value on the current object of <code>cls</code> â€¦</p></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="xboto.dependencies.BotoClient.boto_client"><code class="name">var <span class="ident">boto_client</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def boto_client(self):
    return self.get()</code></pre>
</details>
</dd>
<dt id="xboto.dependencies.BotoClient.obj"><code class="name">var <span class="ident">obj</span> :Â <a title="xinject.dependency.Dependency" href="../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xinject.dependency.Dependency" href="../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></code>.<code><a title="xinject.dependency.Dependency.obj" href="../xinject/dependency.html#xinject.dependency.Dependency.obj">obj</a></code>
</p>
<div class="desc inherited"><p>class property/attribute that will return the current dependency for the subclass
it's asked on by calling <code>Dependency.grab</code>, passing no extra â€¦</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="xboto.dependencies.BotoClient.__call__"><code class="name flex">
<span>def <span class="ident">__call__</span></span>(<span>self, func)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xinject.dependency.Dependency" href="../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></code>.<code><a title="xinject.dependency.Dependency.__call__" href="../xinject/dependency.html#xinject.dependency.Dependency.__call__">__call__</a></code>
</p>
<div class="desc inherited"><p>This makes Resource subclasses have an ability to be used as function decorators
by default unless this method is overriden to provide some other â€¦</p></div>
</dd>
<dt id="xboto.dependencies.BotoClient.__copy__"><code class="name flex">
<span>def <span class="ident">__copy__</span></span>(<span>self)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xinject.dependency.Dependency" href="../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></code>.<code><a title="xinject.dependency.Dependency.__copy__" href="../xinject/dependency.html#xinject.dependency.Dependency.__copy__">__copy__</a></code>
</p>
<div class="desc inherited"><p>Basic shallow copy protection
(I am wondering if I should just remove this default copy code) â€¦</p></div>
</dd>
</dl>
</dd>
<dt id="xboto.dependencies.BotoClients"><code class="flex name class">
<span>class <span class="ident">BotoClients</span></span>
</code></dt>
<dd>
<div class="desc"><p>When you get an attribute off of me, I'll attempt to ask the boto3 library to allocate
a client of the same type, and then store itself, so I return the same client again
in the future.</p>
<p>Right now, we will lazily allocate a boto3 client per-thread, and we will use the
per-thread shared boto3 session resource to do it (ie: <code>_BotoSession.session</code>).</p>
<p>You can also easily import and use the <code><a title="xboto.dependencies.boto_clients" href="#xboto.dependencies.boto_clients">boto_clients</a></code> proxy object
(defined at top module-level).</p>
<p>You can use <code><a title="xboto.dependencies.boto_clients" href="#xboto.dependencies.boto_clients">boto_clients</a></code> exactly the same as using <code><a title="xboto.dependencies.BotoClients.grab" href="../xinject/dependency.html#xboto.dependencies.BotoClients.grab">Dependency.grab()</a></code>,
making it more convenient to use since you can directly import <code><a title="xboto.dependencies.boto_clients" href="#xboto.dependencies.boto_clients">boto_clients</a></code>.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xboto import boto_clients
&gt;&gt;&gt; # Showing here how you could use it:
&gt;&gt;&gt; boto_clients.ssm.get_paginator(...)
</code></pre>
<p>If you have an aws client that uses a <code>-</code> for it's name, you can use an <code>_</code> (underscore)
instead.
All underscores are changed to a <code>-</code> when looking up the aws client.
You can also directly use the <code>xboto.dependencies.BotoClients.load</code> method, and use a <code>-</code>
there.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BotoClients(_Loader, boto_dependency_class=BotoClient):
    &#34;&#34;&#34;
    When you get an attribute off of me, I&#39;ll attempt to ask the boto3 library to allocate
    a client of the same type, and then store itself, so I return the same client again
    in the future.

    Right now, we will lazily allocate a boto3 client per-thread, and we will use the
    per-thread shared boto3 session resource to do it (ie: `_BotoSession.session`).

    You can also easily import and use the `boto_clients` proxy object
    (defined at top module-level).

    You can use `boto_clients` exactly the same as using `BotoClients.grab()`,
    making it more convenient to use since you can directly import `boto_clients`.

    &gt;&gt;&gt; from xboto import boto_clients
    &gt;&gt;&gt; # Showing here how you could use it:
    &gt;&gt;&gt; boto_clients.ssm.get_paginator(...)

    If you have an aws client that uses a `-` for it&#39;s name, you can use an `_` (underscore)
    instead.
    All underscores are changed to a `-` when looking up the aws client.
    You can also directly use the `xboto.dependencies.BotoClients.load` method, and use a `-`
    there.
    &#34;&#34;&#34;

    def _lookup(self, module):
        return BotoClient.get_dependency_cls(module).grab().boto_client

    # These annotations are only for IDE-type-completion;
    # any client boto supports will work regardless (even if not listed below).
    #
    # These are the xyn-resource `Resource` types/classes; ie: BotoClient subclasses
    # (start with upper-case letter)
    AccessAnalyzer: Type[BotoClient]
    Account: Type[BotoClient]
    Acm: Type[BotoClient]
    Acm_Pca: Type[BotoClient]
    AlexaForBusiness: Type[BotoClient]
    Amp: Type[BotoClient]
    Amplify: Type[BotoClient]
    AmplifyBackend: Type[BotoClient]
    AmplifyUiBuilder: Type[BotoClient]
    ApiGateway: Type[BotoClient]
    ApiGatewayManagementApi: Type[BotoClient]
    ApiGatewayV2: Type[BotoClient]
    AppConfig: Type[BotoClient]
    AppConfigData: Type[BotoClient]
    Appflow: Type[BotoClient]
    AppIntegrations: Type[BotoClient]
    Application_Autoscaling: Type[BotoClient]
    Application_Insights: Type[BotoClient]
    Applicationcostprofiler: Type[BotoClient]
    Appmesh: Type[BotoClient]
    Apprunner: Type[BotoClient]
    Appstream: Type[BotoClient]
    Appsync: Type[BotoClient]
    Arc_Zonal_Shift: Type[BotoClient]
    Athena: Type[BotoClient]
    AuditManager: Type[BotoClient]
    Autoscaling: Type[BotoClient]
    Autoscaling_Plans: Type[BotoClient]
    Backup: Type[BotoClient]
    Backup_Gateway: Type[BotoClient]
    BackupStorage: Type[BotoClient]
    Batch: Type[BotoClient]
    BillingConductor: Type[BotoClient]
    Braket: Type[BotoClient]
    Budgets: Type[BotoClient]
    Ce: Type[BotoClient]
    Chime: Type[BotoClient]
    Chime_Sdk_Identity: Type[BotoClient]
    Chime_Sdk_Media_Pipelines: Type[BotoClient]
    Chime_Sdk_Meetings: Type[BotoClient]
    Chime_Sdk_Messaging: Type[BotoClient]
    Chime_Sdk_Voice: Type[BotoClient]
    Cleanrooms: Type[BotoClient]
    Cloud9: Type[BotoClient]
    Cloudcontrol: Type[BotoClient]
    Clouddirectory: Type[BotoClient]
    Cloudformation: Type[BotoClient]
    Cloudfront: Type[BotoClient]
    Cloudhsm: Type[BotoClient]
    Cloudhsmv2: Type[BotoClient]
    Cloudsearch: Type[BotoClient]
    Cloudsearchdomain: Type[BotoClient]
    Cloudtrail: Type[BotoClient]
    Cloudtrail_Data: Type[BotoClient]
    Cloudwatch: Type[BotoClient]
    CodeArtifact: Type[BotoClient]
    CodeBuild: Type[BotoClient]
    CodeCatalyst: Type[BotoClient]
    CodeCommit: Type[BotoClient]
    CodeDeploy: Type[BotoClient]
    Codeguru_Reviewer: Type[BotoClient]
    CodeguruProfiler: Type[BotoClient]
    CodePipeline: Type[BotoClient]
    Codestar: Type[BotoClient]
    Codestar_Connections: Type[BotoClient]
    Codestar_Notifications: Type[BotoClient]
    Cognito_Identity: Type[BotoClient]
    Cognito_Idp: Type[BotoClient]
    Cognito_Sync: Type[BotoClient]
    Comprehend: Type[BotoClient]
    Comprehendmedical: Type[BotoClient]
    Compute_Optimizer: Type[BotoClient]
    Config: Type[BotoClient]
    Connect: Type[BotoClient]
    Connect_Contact_Lens: Type[BotoClient]
    ConnectCampaigns: Type[BotoClient]
    ConnectCases: Type[BotoClient]
    ConnectParticipant: Type[BotoClient]
    ControlTower: Type[BotoClient]
    Cur: Type[BotoClient]
    Customer_Profiles: Type[BotoClient]
    DataBrew: Type[BotoClient]
    DataExchange: Type[BotoClient]
    DataPipeline: Type[BotoClient]
    DataSync: Type[BotoClient]
    Dax: Type[BotoClient]
    Detective: Type[BotoClient]
    Devicefarm: Type[BotoClient]
    Devops_Guru: Type[BotoClient]
    DirectConnect: Type[BotoClient]
    Discovery: Type[BotoClient]
    Dlm: Type[BotoClient]
    Dms: Type[BotoClient]
    Docdb: Type[BotoClient]
    Docdb_Elastic: Type[BotoClient]
    Drs: Type[BotoClient]
    Ds: Type[BotoClient]
    DynamoDb: Type[BotoClient]
    DynamoDbStreams: Type[BotoClient]
    Ebs: Type[BotoClient]
    Ec2: Type[BotoClient]
    Ec2_Instance_Connect: Type[BotoClient]
    Ecr: Type[BotoClient]
    Ecr_Public: Type[BotoClient]
    Ecs: Type[BotoClient]
    Efs: Type[BotoClient]
    Eks: Type[BotoClient]
    Elastic_Inference: Type[BotoClient]
    Elasticache: Type[BotoClient]
    ElasticBeanstalk: Type[BotoClient]
    ElasticTranscoder: Type[BotoClient]
    Elb: Type[BotoClient]
    Elbv2: Type[BotoClient]
    Emr: Type[BotoClient]
    Emr_Containers: Type[BotoClient]
    Emr_Serverless: Type[BotoClient]
    Es: Type[BotoClient]
    Events: Type[BotoClient]
    Evidently: Type[BotoClient]
    Finspace: Type[BotoClient]
    Finspace_Data: Type[BotoClient]
    Firehose: Type[BotoClient]
    Fis: Type[BotoClient]
    Fms: Type[BotoClient]
    Forecast: Type[BotoClient]
    Forecastquery: Type[BotoClient]
    Frauddetector: Type[BotoClient]
    Fsx: Type[BotoClient]
    Gamelift: Type[BotoClient]
    Gamesparks: Type[BotoClient]
    Glacier: Type[BotoClient]
    Globalaccelerator: Type[BotoClient]
    Glue: Type[BotoClient]
    Grafana: Type[BotoClient]
    Greengrass: Type[BotoClient]
    Greengrassv2: Type[BotoClient]
    Groundstation: Type[BotoClient]
    Guardduty: Type[BotoClient]
    Health: Type[BotoClient]
    Healthlake: Type[BotoClient]
    Honeycode: Type[BotoClient]
    Iam: Type[BotoClient]
    IdentityStore: Type[BotoClient]
    ImageBuilder: Type[BotoClient]
    ImportExport: Type[BotoClient]
    Inspector: Type[BotoClient]
    Inspector2: Type[BotoClient]
    Iot: Type[BotoClient]
    Iot_Data: Type[BotoClient]
    Iot_Jobs_Data: Type[BotoClient]
    Iot_Roborunner: Type[BotoClient]
    Iot1Click_Devices: Type[BotoClient]
    Iot1Click_Projects: Type[BotoClient]
    IotAnalytics: Type[BotoClient]
    IotDeviceAdvisor: Type[BotoClient]
    IotEvents: Type[BotoClient]
    IotEvents_Data: Type[BotoClient]
    IotFleethub: Type[BotoClient]
    IotFleetwise: Type[BotoClient]
    IotSecureTunneling: Type[BotoClient]
    IotSitewise: Type[BotoClient]
    IotThingsgraph: Type[BotoClient]
    IotTwinmaker: Type[BotoClient]
    IotWireless: Type[BotoClient]
    Ivs: Type[BotoClient]
    Ivschat: Type[BotoClient]
    Kafka: Type[BotoClient]
    Kafkaconnect: Type[BotoClient]
    Kendra: Type[BotoClient]
    Kendra_Ranking: Type[BotoClient]
    Keyspaces: Type[BotoClient]
    Kinesis: Type[BotoClient]
    Kinesis_Video_Archived_Media: Type[BotoClient]
    Kinesis_Video_Media: Type[BotoClient]
    Kinesis_Video_Signaling: Type[BotoClient]
    Kinesis_Video_Webrtc_Storage: Type[BotoClient]
    KinesisAnalytics: Type[BotoClient]
    KinesisAnalyticsv2: Type[BotoClient]
    Kinesisvideo: Type[BotoClient]
    Kms: Type[BotoClient]
    Lakeformation: Type[BotoClient]
    # Lambda Is A Key-Word, Underscore Is Ignored.
    Lambda_: Type[BotoClient]
    Lex_Models: Type[BotoClient]
    Lex_Runtime: Type[BotoClient]
    Lexv2_Models: Type[BotoClient]
    Lexv2_Runtime: Type[BotoClient]
    License_Manager: Type[BotoClient]
    License_Manager_Linux_Subscriptions: Type[BotoClient]
    License_Manager_User_Subscriptions: Type[BotoClient]
    Lightsail: Type[BotoClient]
    Location: Type[BotoClient]
    Logs: Type[BotoClient]
    LookoutEquipment: Type[BotoClient]
    LookoutMetrics: Type[BotoClient]
    LookoutVision: Type[BotoClient]
    M2: Type[BotoClient]
    MachineLearning: Type[BotoClient]
    Macie: Type[BotoClient]
    Macie2: Type[BotoClient]
    ManagedBlockchain: Type[BotoClient]
    MarketPlace_Catalog: Type[BotoClient]
    MarketPlace_Entitlement: Type[BotoClient]
    MarketPlacecommerceanalytics: Type[BotoClient]
    MediaConnect: Type[BotoClient]
    MediaConvert: Type[BotoClient]
    MediaLive: Type[BotoClient]
    MediaPackage: Type[BotoClient]
    MediaPackage_Vod: Type[BotoClient]
    MediaStore: Type[BotoClient]
    MediaStore_Data: Type[BotoClient]
    MediaTailor: Type[BotoClient]
    MemoryDb: Type[BotoClient]
    MeteringMarketplace: Type[BotoClient]
    Mgh: Type[BotoClient]
    Mgn: Type[BotoClient]
    Migration_Hub_Refactor_Spaces: Type[BotoClient]
    MigrationHub_Config: Type[BotoClient]
    MigrationHubOrchestrator: Type[BotoClient]
    MigrationHubStrategy: Type[BotoClient]
    Mobile: Type[BotoClient]
    Mq: Type[BotoClient]
    Mturk: Type[BotoClient]
    Mwaa: Type[BotoClient]
    Neptune: Type[BotoClient]
    Network_Firewall: Type[BotoClient]
    Networkmanager: Type[BotoClient]
    Nimble: Type[BotoClient]
    Oam: Type[BotoClient]
    Omics: Type[BotoClient]
    Opensearch: Type[BotoClient]
    OpensearchServerless: Type[BotoClient]
    Opsworks: Type[BotoClient]
    Opsworkscm: Type[BotoClient]
    Organizations: Type[BotoClient]
    Outposts: Type[BotoClient]
    Panorama: Type[BotoClient]
    Personalize: Type[BotoClient]
    Personalize_Events: Type[BotoClient]
    Personalize_Runtime: Type[BotoClient]
    Pi: Type[BotoClient]
    Pinpoint: Type[BotoClient]
    Pinpoint_Email: Type[BotoClient]
    Pinpoint_Sms_Voice: Type[BotoClient]
    Pinpoint_Sms_Voice_V2: Type[BotoClient]
    Pipes: Type[BotoClient]
    Polly: Type[BotoClient]
    Pricing: Type[BotoClient]
    Privatenetworks: Type[BotoClient]
    Proton: Type[BotoClient]
    Qldb: Type[BotoClient]
    Qldb_Session: Type[BotoClient]
    Quicksight: Type[BotoClient]
    Ram: Type[BotoClient]
    Rbin: Type[BotoClient]
    Rds: Type[BotoClient]
    Rds_Data: Type[BotoClient]
    Redshift: Type[BotoClient]
    Redshift_Data: Type[BotoClient]
    Redshift_Serverless: Type[BotoClient]
    Rekognition: Type[BotoClient]
    Resiliencehub: Type[BotoClient]
    Resource_Explorer_2: Type[BotoClient]
    Resource_Groups: Type[BotoClient]
    ResourceGroupStaggingApi: Type[BotoClient]
    Robomaker: Type[BotoClient]
    Rolesanywhere: Type[BotoClient]
    Route53: Type[BotoClient]
    Route53_Recovery_Cluster: Type[BotoClient]
    Route53_Recovery_Control_Config: Type[BotoClient]
    Route53_Recovery_Readiness: Type[BotoClient]
    Route53Domains: Type[BotoClient]
    Route53Resolver: Type[BotoClient]
    Rum: Type[BotoClient]
    S3: Type[BotoClient]
    S3Control: Type[BotoClient]
    S3Outposts: Type[BotoClient]
    Sagemaker: Type[BotoClient]
    Sagemaker_A2I_Runtime: Type[BotoClient]
    Sagemaker_Edge: Type[BotoClient]
    Sagemaker_Featurestore_Runtime: Type[BotoClient]
    Sagemaker_Geospatial: Type[BotoClient]
    Sagemaker_Metrics: Type[BotoClient]
    Sagemaker_Runtime: Type[BotoClient]
    SavingsPlans: Type[BotoClient]
    Scheduler: Type[BotoClient]
    Schemas: Type[BotoClient]
    Sdb: Type[BotoClient]
    Secretsmanager: Type[BotoClient]
    Securityhub: Type[BotoClient]
    Securitylake: Type[BotoClient]
    Serverlessrepo: Type[BotoClient]
    Service_Quotas: Type[BotoClient]
    ServiceCatalog: Type[BotoClient]
    ServiceCatalog_Appregistry: Type[BotoClient]
    ServiceDiscovery: Type[BotoClient]
    Ses: Type[BotoClient]
    Sesv2: Type[BotoClient]
    Shield: Type[BotoClient]
    Signer: Type[BotoClient]
    Simspaceweaver: Type[BotoClient]
    Sms: Type[BotoClient]
    Sms_Voice: Type[BotoClient]
    Snow_Device_Management: Type[BotoClient]
    Snowball: Type[BotoClient]
    Sns: Type[BotoClient]
    Sqs: Type[BotoClient]
    Ssm: Type[BotoClient]
    Ssm_Contacts: Type[BotoClient]
    Ssm_Incidents: Type[BotoClient]
    Ssm_Sap: Type[BotoClient]
    Sso: Type[BotoClient]
    Sso_Admin: Type[BotoClient]
    Sso_Oidc: Type[BotoClient]
    StepFunctions: Type[BotoClient]
    StorageGateway: Type[BotoClient]
    Sts: Type[BotoClient]
    Support: Type[BotoClient]
    Support_App: Type[BotoClient]
    Swf: Type[BotoClient]
    Synthetics: Type[BotoClient]
    Textract: Type[BotoClient]
    Timestream_Query: Type[BotoClient]
    Timestream_Write: Type[BotoClient]
    Transcribe: Type[BotoClient]
    Transfer: Type[BotoClient]
    Translate: Type[BotoClient]
    Voice_Id: Type[BotoClient]
    Waf: Type[BotoClient]
    Waf_Regional: Type[BotoClient]
    Wafv2: Type[BotoClient]
    WellArchitected: Type[BotoClient]
    Wisdom: Type[BotoClient]
    Workdocs: Type[BotoClient]
    Worklink: Type[BotoClient]
    Workmail: Type[BotoClient]
    WorkmailMessageFlow: Type[BotoClient]
    Workspaces: Type[BotoClient]
    Workspaces_Web: Type[BotoClient]
    Xray: Type[BotoClient]

    # These annotations are only for IDE-type-completion;
    # any client boto supports will work regardless (even if not listed below).
    #
    # These are the boto client objects (start with lower-case letter)
    accessanalyzer: Any
    account: Any
    acm: Any
    acm_pca: Any
    alexaforbusiness: Any
    amp: Any
    amplify: Any
    amplifybackend: Any
    amplifyuibuilder: Any
    apigateway: Any
    apigatewaymanagementapi: Any
    apigatewayv2: Any
    appconfig: Any
    appconfigdata: Any
    appflow: Any
    appintegrations: Any
    application_autoscaling: Any
    application_insights: Any
    applicationcostprofiler: Any
    appmesh: Any
    apprunner: Any
    appstream: Any
    appsync: Any
    arc_zonal_shift: Any
    athena: Any
    auditmanager: Any
    autoscaling: Any
    autoscaling_plans: Any
    backup: Any
    backup_gateway: Any
    backupstorage: Any
    batch: Any
    billingconductor: Any
    braket: Any
    budgets: Any
    ce: Any
    chime: Any
    chime_sdk_identity: Any
    chime_sdk_media_pipelines: Any
    chime_sdk_meetings: Any
    chime_sdk_messaging: Any
    chime_sdk_voice: Any
    cleanrooms: Any
    cloud9: Any
    cloudcontrol: Any
    clouddirectory: Any
    cloudformation: Any
    cloudfront: Any
    cloudhsm: Any
    cloudhsmv2: Any
    cloudsearch: Any
    cloudsearchdomain: Any
    cloudtrail: Any
    cloudtrail_data: Any
    cloudwatch: Any
    codeartifact: Any
    codebuild: Any
    codecatalyst: Any
    codecommit: Any
    codedeploy: Any
    codeguru_reviewer: Any
    codeguruprofiler: Any
    codepipeline: Any
    codestar: Any
    codestar_connections: Any
    codestar_notifications: Any
    cognito_identity: Any
    cognito_idp: Any
    cognito_sync: Any
    comprehend: Any
    comprehendmedical: Any
    compute_optimizer: Any
    config: Any
    connect: Any
    connect_contact_lens: Any
    connectcampaigns: Any
    connectcases: Any
    connectparticipant: Any
    controltower: Any
    cur: Any
    customer_profiles: Any
    databrew: Any
    dataexchange: Any
    datapipeline: Any
    datasync: Any
    dax: Any
    detective: Any
    devicefarm: Any
    devops_guru: Any
    directconnect: Any
    discovery: Any
    dlm: Any
    dms: Any
    docdb: Any
    docdb_elastic: Any
    drs: Any
    ds: Any
    dynamodb: Any
    dynamodbstreams: Any
    ebs: Any
    ec2: Any
    ec2_instance_connect: Any
    ecr: Any
    ecr_public: Any
    ecs: Any
    efs: Any
    eks: Any
    elastic_inference: Any
    elasticache: Any
    elasticbeanstalk: Any
    elastictranscoder: Any
    elb: Any
    elbv2: Any
    emr: Any
    emr_containers: Any
    emr_serverless: Any
    es: Any
    events: Any
    evidently: Any
    finspace: Any
    finspace_data: Any
    firehose: Any
    fis: Any
    fms: Any
    forecast: Any
    forecastquery: Any
    frauddetector: Any
    fsx: Any
    gamelift: Any
    gamesparks: Any
    glacier: Any
    globalaccelerator: Any
    glue: Any
    grafana: Any
    greengrass: Any
    greengrassv2: Any
    groundstation: Any
    guardduty: Any
    health: Any
    healthlake: Any
    honeycode: Any
    iam: Any
    identitystore: Any
    imagebuilder: Any
    importexport: Any
    inspector: Any
    inspector2: Any
    iot: Any
    iot_data: Any
    iot_jobs_data: Any
    iot_roborunner: Any
    iot1click_devices: Any
    iot1click_projects: Any
    iotanalytics: Any
    iotdeviceadvisor: Any
    iotevents: Any
    iotevents_data: Any
    iotfleethub: Any
    iotfleetwise: Any
    iotsecuretunneling: Any
    iotsitewise: Any
    iotthingsgraph: Any
    iottwinmaker: Any
    iotwireless: Any
    ivs: Any
    ivschat: Any
    kafka: Any
    kafkaconnect: Any
    kendra: Any
    kendra_ranking: Any
    keyspaces: Any
    kinesis: Any
    kinesis_video_archived_media: Any
    kinesis_video_media: Any
    kinesis_video_signaling: Any
    kinesis_video_webrtc_storage: Any
    kinesisanalytics: Any
    kinesisanalyticsv2: Any
    kinesisvideo: Any
    kms: Any
    lakeformation: Any
    # Lambda is a key-word, underscore is ignored.
    lambda_: Any
    lex_models: Any
    lex_runtime: Any
    lexv2_models: Any
    lexv2_runtime: Any
    license_manager: Any
    license_manager_linux_subscriptions: Any
    license_manager_user_subscriptions: Any
    lightsail: Any
    location: Any
    logs: Any
    lookoutequipment: Any
    lookoutmetrics: Any
    lookoutvision: Any
    m2: Any
    machinelearning: Any
    macie: Any
    macie2: Any
    managedblockchain: Any
    marketplace_catalog: Any
    marketplace_entitlement: Any
    marketplacecommerceanalytics: Any
    mediaconnect: Any
    mediaconvert: Any
    medialive: Any
    mediapackage: Any
    mediapackage_vod: Any
    mediastore: Any
    mediastore_data: Any
    mediatailor: Any
    memorydb: Any
    meteringmarketplace: Any
    mgh: Any
    mgn: Any
    migration_hub_refactor_spaces: Any
    migrationhub_config: Any
    migrationhuborchestrator: Any
    migrationhubstrategy: Any
    mobile: Any
    mq: Any
    mturk: Any
    mwaa: Any
    neptune: Any
    network_firewall: Any
    networkmanager: Any
    nimble: Any
    oam: Any
    omics: Any
    opensearch: Any
    opensearchserverless: Any
    opsworks: Any
    opsworkscm: Any
    organizations: Any
    outposts: Any
    panorama: Any
    personalize: Any
    personalize_events: Any
    personalize_runtime: Any
    pi: Any
    pinpoint: Any
    pinpoint_email: Any
    pinpoint_sms_voice: Any
    pinpoint_sms_voice_v2: Any
    pipes: Any
    polly: Any
    pricing: Any
    privatenetworks: Any
    proton: Any
    qldb: Any
    qldb_session: Any
    quicksight: Any
    ram: Any
    rbin: Any
    rds: Any
    rds_data: Any
    redshift: Any
    redshift_data: Any
    redshift_serverless: Any
    rekognition: Any
    resiliencehub: Any
    resource_explorer_2: Any
    resource_groups: Any
    resourcegroupstaggingapi: Any
    robomaker: Any
    rolesanywhere: Any
    route53: Any
    route53_recovery_cluster: Any
    route53_recovery_control_config: Any
    route53_recovery_readiness: Any
    route53domains: Any
    route53resolver: Any
    rum: Any
    s3: Any
    s3control: Any
    s3outposts: Any
    sagemaker: Any
    sagemaker_a2i_runtime: Any
    sagemaker_edge: Any
    sagemaker_featurestore_runtime: Any
    sagemaker_geospatial: Any
    sagemaker_metrics: Any
    sagemaker_runtime: Any
    savingsplans: Any
    scheduler: Any
    schemas: Any
    sdb: Any
    secretsmanager: Any
    securityhub: Any
    securitylake: Any
    serverlessrepo: Any
    service_quotas: Any
    servicecatalog: Any
    servicecatalog_appregistry: Any
    servicediscovery: Any
    ses: Any
    sesv2: Any
    shield: Any
    signer: Any
    simspaceweaver: Any
    sms: Any
    sms_voice: Any
    snow_device_management: Any
    snowball: Any
    sns: Any
    sqs: Any
    ssm: Any
    ssm_contacts: Any
    ssm_incidents: Any
    ssm_sap: Any
    sso: Any
    sso_admin: Any
    sso_oidc: Any
    stepfunctions: Any
    storagegateway: Any
    sts: Any
    support: Any
    support_app: Any
    swf: Any
    synthetics: Any
    textract: Any
    timestream_query: Any
    timestream_write: Any
    transcribe: Any
    transfer: Any
    translate: Any
    voice_id: Any
    waf: Any
    waf_regional: Any
    wafv2: Any
    wellarchitected: Any
    wisdom: Any
    workdocs: Any
    worklink: Any
    workmail: Any
    workmailmessageflow: Any
    workspaces: Any
    workspaces_web: Any
    xray: Any</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>xboto.dependencies._Loader</li>
<li><a title="xinject.dependency.Dependency" href="../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="xboto.dependencies.BotoClients.AccessAnalyzer"><code class="name">var <span class="ident">AccessAnalyzer</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Account"><code class="name">var <span class="ident">Account</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Acm"><code class="name">var <span class="ident">Acm</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Acm_Pca"><code class="name">var <span class="ident">Acm_Pca</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.AlexaForBusiness"><code class="name">var <span class="ident">AlexaForBusiness</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Amp"><code class="name">var <span class="ident">Amp</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Amplify"><code class="name">var <span class="ident">Amplify</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.AmplifyBackend"><code class="name">var <span class="ident">AmplifyBackend</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.AmplifyUiBuilder"><code class="name">var <span class="ident">AmplifyUiBuilder</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.ApiGateway"><code class="name">var <span class="ident">ApiGateway</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.ApiGatewayManagementApi"><code class="name">var <span class="ident">ApiGatewayManagementApi</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.ApiGatewayV2"><code class="name">var <span class="ident">ApiGatewayV2</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.AppConfig"><code class="name">var <span class="ident">AppConfig</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.AppConfigData"><code class="name">var <span class="ident">AppConfigData</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.AppIntegrations"><code class="name">var <span class="ident">AppIntegrations</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Appflow"><code class="name">var <span class="ident">Appflow</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Application_Autoscaling"><code class="name">var <span class="ident">Application_Autoscaling</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Application_Insights"><code class="name">var <span class="ident">Application_Insights</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Applicationcostprofiler"><code class="name">var <span class="ident">Applicationcostprofiler</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Appmesh"><code class="name">var <span class="ident">Appmesh</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Apprunner"><code class="name">var <span class="ident">Apprunner</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Appstream"><code class="name">var <span class="ident">Appstream</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Appsync"><code class="name">var <span class="ident">Appsync</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Arc_Zonal_Shift"><code class="name">var <span class="ident">Arc_Zonal_Shift</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Athena"><code class="name">var <span class="ident">Athena</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.AuditManager"><code class="name">var <span class="ident">AuditManager</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Autoscaling"><code class="name">var <span class="ident">Autoscaling</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Autoscaling_Plans"><code class="name">var <span class="ident">Autoscaling_Plans</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Backup"><code class="name">var <span class="ident">Backup</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.BackupStorage"><code class="name">var <span class="ident">BackupStorage</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Backup_Gateway"><code class="name">var <span class="ident">Backup_Gateway</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Batch"><code class="name">var <span class="ident">Batch</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.BillingConductor"><code class="name">var <span class="ident">BillingConductor</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Braket"><code class="name">var <span class="ident">Braket</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Budgets"><code class="name">var <span class="ident">Budgets</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Ce"><code class="name">var <span class="ident">Ce</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Chime"><code class="name">var <span class="ident">Chime</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Chime_Sdk_Identity"><code class="name">var <span class="ident">Chime_Sdk_Identity</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Chime_Sdk_Media_Pipelines"><code class="name">var <span class="ident">Chime_Sdk_Media_Pipelines</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Chime_Sdk_Meetings"><code class="name">var <span class="ident">Chime_Sdk_Meetings</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Chime_Sdk_Messaging"><code class="name">var <span class="ident">Chime_Sdk_Messaging</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Chime_Sdk_Voice"><code class="name">var <span class="ident">Chime_Sdk_Voice</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Cleanrooms"><code class="name">var <span class="ident">Cleanrooms</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Cloud9"><code class="name">var <span class="ident">Cloud9</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Cloudcontrol"><code class="name">var <span class="ident">Cloudcontrol</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Clouddirectory"><code class="name">var <span class="ident">Clouddirectory</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Cloudformation"><code class="name">var <span class="ident">Cloudformation</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Cloudfront"><code class="name">var <span class="ident">Cloudfront</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Cloudhsm"><code class="name">var <span class="ident">Cloudhsm</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Cloudhsmv2"><code class="name">var <span class="ident">Cloudhsmv2</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Cloudsearch"><code class="name">var <span class="ident">Cloudsearch</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Cloudsearchdomain"><code class="name">var <span class="ident">Cloudsearchdomain</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Cloudtrail"><code class="name">var <span class="ident">Cloudtrail</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Cloudtrail_Data"><code class="name">var <span class="ident">Cloudtrail_Data</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Cloudwatch"><code class="name">var <span class="ident">Cloudwatch</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.CodeArtifact"><code class="name">var <span class="ident">CodeArtifact</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.CodeBuild"><code class="name">var <span class="ident">CodeBuild</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.CodeCatalyst"><code class="name">var <span class="ident">CodeCatalyst</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.CodeCommit"><code class="name">var <span class="ident">CodeCommit</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.CodeDeploy"><code class="name">var <span class="ident">CodeDeploy</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.CodePipeline"><code class="name">var <span class="ident">CodePipeline</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.CodeguruProfiler"><code class="name">var <span class="ident">CodeguruProfiler</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Codeguru_Reviewer"><code class="name">var <span class="ident">Codeguru_Reviewer</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Codestar"><code class="name">var <span class="ident">Codestar</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Codestar_Connections"><code class="name">var <span class="ident">Codestar_Connections</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Codestar_Notifications"><code class="name">var <span class="ident">Codestar_Notifications</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Cognito_Identity"><code class="name">var <span class="ident">Cognito_Identity</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Cognito_Idp"><code class="name">var <span class="ident">Cognito_Idp</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Cognito_Sync"><code class="name">var <span class="ident">Cognito_Sync</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Comprehend"><code class="name">var <span class="ident">Comprehend</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Comprehendmedical"><code class="name">var <span class="ident">Comprehendmedical</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Compute_Optimizer"><code class="name">var <span class="ident">Compute_Optimizer</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Config"><code class="name">var <span class="ident">Config</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Connect"><code class="name">var <span class="ident">Connect</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.ConnectCampaigns"><code class="name">var <span class="ident">ConnectCampaigns</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.ConnectCases"><code class="name">var <span class="ident">ConnectCases</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.ConnectParticipant"><code class="name">var <span class="ident">ConnectParticipant</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Connect_Contact_Lens"><code class="name">var <span class="ident">Connect_Contact_Lens</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.ControlTower"><code class="name">var <span class="ident">ControlTower</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Cur"><code class="name">var <span class="ident">Cur</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Customer_Profiles"><code class="name">var <span class="ident">Customer_Profiles</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.DataBrew"><code class="name">var <span class="ident">DataBrew</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.DataExchange"><code class="name">var <span class="ident">DataExchange</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.DataPipeline"><code class="name">var <span class="ident">DataPipeline</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.DataSync"><code class="name">var <span class="ident">DataSync</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Dax"><code class="name">var <span class="ident">Dax</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Detective"><code class="name">var <span class="ident">Detective</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Devicefarm"><code class="name">var <span class="ident">Devicefarm</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Devops_Guru"><code class="name">var <span class="ident">Devops_Guru</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.DirectConnect"><code class="name">var <span class="ident">DirectConnect</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Discovery"><code class="name">var <span class="ident">Discovery</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Dlm"><code class="name">var <span class="ident">Dlm</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Dms"><code class="name">var <span class="ident">Dms</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Docdb"><code class="name">var <span class="ident">Docdb</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Docdb_Elastic"><code class="name">var <span class="ident">Docdb_Elastic</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Drs"><code class="name">var <span class="ident">Drs</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Ds"><code class="name">var <span class="ident">Ds</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.DynamoDb"><code class="name">var <span class="ident">DynamoDb</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.DynamoDbStreams"><code class="name">var <span class="ident">DynamoDbStreams</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Ebs"><code class="name">var <span class="ident">Ebs</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Ec2"><code class="name">var <span class="ident">Ec2</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Ec2_Instance_Connect"><code class="name">var <span class="ident">Ec2_Instance_Connect</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Ecr"><code class="name">var <span class="ident">Ecr</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Ecr_Public"><code class="name">var <span class="ident">Ecr_Public</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Ecs"><code class="name">var <span class="ident">Ecs</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Efs"><code class="name">var <span class="ident">Efs</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Eks"><code class="name">var <span class="ident">Eks</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.ElasticBeanstalk"><code class="name">var <span class="ident">ElasticBeanstalk</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.ElasticTranscoder"><code class="name">var <span class="ident">ElasticTranscoder</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Elastic_Inference"><code class="name">var <span class="ident">Elastic_Inference</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Elasticache"><code class="name">var <span class="ident">Elasticache</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Elb"><code class="name">var <span class="ident">Elb</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Elbv2"><code class="name">var <span class="ident">Elbv2</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Emr"><code class="name">var <span class="ident">Emr</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Emr_Containers"><code class="name">var <span class="ident">Emr_Containers</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Emr_Serverless"><code class="name">var <span class="ident">Emr_Serverless</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Es"><code class="name">var <span class="ident">Es</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Events"><code class="name">var <span class="ident">Events</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Evidently"><code class="name">var <span class="ident">Evidently</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Finspace"><code class="name">var <span class="ident">Finspace</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Finspace_Data"><code class="name">var <span class="ident">Finspace_Data</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Firehose"><code class="name">var <span class="ident">Firehose</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Fis"><code class="name">var <span class="ident">Fis</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Fms"><code class="name">var <span class="ident">Fms</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Forecast"><code class="name">var <span class="ident">Forecast</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Forecastquery"><code class="name">var <span class="ident">Forecastquery</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Frauddetector"><code class="name">var <span class="ident">Frauddetector</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Fsx"><code class="name">var <span class="ident">Fsx</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Gamelift"><code class="name">var <span class="ident">Gamelift</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Gamesparks"><code class="name">var <span class="ident">Gamesparks</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Glacier"><code class="name">var <span class="ident">Glacier</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Globalaccelerator"><code class="name">var <span class="ident">Globalaccelerator</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Glue"><code class="name">var <span class="ident">Glue</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Grafana"><code class="name">var <span class="ident">Grafana</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Greengrass"><code class="name">var <span class="ident">Greengrass</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Greengrassv2"><code class="name">var <span class="ident">Greengrassv2</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Groundstation"><code class="name">var <span class="ident">Groundstation</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Guardduty"><code class="name">var <span class="ident">Guardduty</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Health"><code class="name">var <span class="ident">Health</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Healthlake"><code class="name">var <span class="ident">Healthlake</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Honeycode"><code class="name">var <span class="ident">Honeycode</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Iam"><code class="name">var <span class="ident">Iam</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.IdentityStore"><code class="name">var <span class="ident">IdentityStore</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.ImageBuilder"><code class="name">var <span class="ident">ImageBuilder</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.ImportExport"><code class="name">var <span class="ident">ImportExport</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Inspector"><code class="name">var <span class="ident">Inspector</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Inspector2"><code class="name">var <span class="ident">Inspector2</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Iot"><code class="name">var <span class="ident">Iot</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Iot1Click_Devices"><code class="name">var <span class="ident">Iot1Click_Devices</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Iot1Click_Projects"><code class="name">var <span class="ident">Iot1Click_Projects</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.IotAnalytics"><code class="name">var <span class="ident">IotAnalytics</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.IotDeviceAdvisor"><code class="name">var <span class="ident">IotDeviceAdvisor</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.IotEvents"><code class="name">var <span class="ident">IotEvents</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.IotEvents_Data"><code class="name">var <span class="ident">IotEvents_Data</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.IotFleethub"><code class="name">var <span class="ident">IotFleethub</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.IotFleetwise"><code class="name">var <span class="ident">IotFleetwise</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.IotSecureTunneling"><code class="name">var <span class="ident">IotSecureTunneling</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.IotSitewise"><code class="name">var <span class="ident">IotSitewise</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.IotThingsgraph"><code class="name">var <span class="ident">IotThingsgraph</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.IotTwinmaker"><code class="name">var <span class="ident">IotTwinmaker</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.IotWireless"><code class="name">var <span class="ident">IotWireless</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Iot_Data"><code class="name">var <span class="ident">Iot_Data</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Iot_Jobs_Data"><code class="name">var <span class="ident">Iot_Jobs_Data</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Iot_Roborunner"><code class="name">var <span class="ident">Iot_Roborunner</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Ivs"><code class="name">var <span class="ident">Ivs</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Ivschat"><code class="name">var <span class="ident">Ivschat</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Kafka"><code class="name">var <span class="ident">Kafka</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Kafkaconnect"><code class="name">var <span class="ident">Kafkaconnect</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Kendra"><code class="name">var <span class="ident">Kendra</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Kendra_Ranking"><code class="name">var <span class="ident">Kendra_Ranking</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Keyspaces"><code class="name">var <span class="ident">Keyspaces</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Kinesis"><code class="name">var <span class="ident">Kinesis</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.KinesisAnalytics"><code class="name">var <span class="ident">KinesisAnalytics</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.KinesisAnalyticsv2"><code class="name">var <span class="ident">KinesisAnalyticsv2</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Kinesis_Video_Archived_Media"><code class="name">var <span class="ident">Kinesis_Video_Archived_Media</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Kinesis_Video_Media"><code class="name">var <span class="ident">Kinesis_Video_Media</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Kinesis_Video_Signaling"><code class="name">var <span class="ident">Kinesis_Video_Signaling</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Kinesis_Video_Webrtc_Storage"><code class="name">var <span class="ident">Kinesis_Video_Webrtc_Storage</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Kinesisvideo"><code class="name">var <span class="ident">Kinesisvideo</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Kms"><code class="name">var <span class="ident">Kms</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Lakeformation"><code class="name">var <span class="ident">Lakeformation</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Lambda_"><code class="name">var <span class="ident">Lambda_</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Lex_Models"><code class="name">var <span class="ident">Lex_Models</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Lex_Runtime"><code class="name">var <span class="ident">Lex_Runtime</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Lexv2_Models"><code class="name">var <span class="ident">Lexv2_Models</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Lexv2_Runtime"><code class="name">var <span class="ident">Lexv2_Runtime</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.License_Manager"><code class="name">var <span class="ident">License_Manager</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.License_Manager_Linux_Subscriptions"><code class="name">var <span class="ident">License_Manager_Linux_Subscriptions</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.License_Manager_User_Subscriptions"><code class="name">var <span class="ident">License_Manager_User_Subscriptions</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Lightsail"><code class="name">var <span class="ident">Lightsail</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Location"><code class="name">var <span class="ident">Location</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Logs"><code class="name">var <span class="ident">Logs</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.LookoutEquipment"><code class="name">var <span class="ident">LookoutEquipment</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.LookoutMetrics"><code class="name">var <span class="ident">LookoutMetrics</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.LookoutVision"><code class="name">var <span class="ident">LookoutVision</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.M2"><code class="name">var <span class="ident">M2</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.MachineLearning"><code class="name">var <span class="ident">MachineLearning</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Macie"><code class="name">var <span class="ident">Macie</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Macie2"><code class="name">var <span class="ident">Macie2</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.ManagedBlockchain"><code class="name">var <span class="ident">ManagedBlockchain</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.MarketPlace_Catalog"><code class="name">var <span class="ident">MarketPlace_Catalog</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.MarketPlace_Entitlement"><code class="name">var <span class="ident">MarketPlace_Entitlement</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.MarketPlacecommerceanalytics"><code class="name">var <span class="ident">MarketPlacecommerceanalytics</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.MediaConnect"><code class="name">var <span class="ident">MediaConnect</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.MediaConvert"><code class="name">var <span class="ident">MediaConvert</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.MediaLive"><code class="name">var <span class="ident">MediaLive</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.MediaPackage"><code class="name">var <span class="ident">MediaPackage</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.MediaPackage_Vod"><code class="name">var <span class="ident">MediaPackage_Vod</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.MediaStore"><code class="name">var <span class="ident">MediaStore</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.MediaStore_Data"><code class="name">var <span class="ident">MediaStore_Data</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.MediaTailor"><code class="name">var <span class="ident">MediaTailor</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.MemoryDb"><code class="name">var <span class="ident">MemoryDb</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.MeteringMarketplace"><code class="name">var <span class="ident">MeteringMarketplace</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Mgh"><code class="name">var <span class="ident">Mgh</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Mgn"><code class="name">var <span class="ident">Mgn</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.MigrationHubOrchestrator"><code class="name">var <span class="ident">MigrationHubOrchestrator</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.MigrationHubStrategy"><code class="name">var <span class="ident">MigrationHubStrategy</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.MigrationHub_Config"><code class="name">var <span class="ident">MigrationHub_Config</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Migration_Hub_Refactor_Spaces"><code class="name">var <span class="ident">Migration_Hub_Refactor_Spaces</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Mobile"><code class="name">var <span class="ident">Mobile</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Mq"><code class="name">var <span class="ident">Mq</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Mturk"><code class="name">var <span class="ident">Mturk</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Mwaa"><code class="name">var <span class="ident">Mwaa</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Neptune"><code class="name">var <span class="ident">Neptune</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Network_Firewall"><code class="name">var <span class="ident">Network_Firewall</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Networkmanager"><code class="name">var <span class="ident">Networkmanager</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Nimble"><code class="name">var <span class="ident">Nimble</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Oam"><code class="name">var <span class="ident">Oam</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Omics"><code class="name">var <span class="ident">Omics</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Opensearch"><code class="name">var <span class="ident">Opensearch</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.OpensearchServerless"><code class="name">var <span class="ident">OpensearchServerless</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Opsworks"><code class="name">var <span class="ident">Opsworks</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Opsworkscm"><code class="name">var <span class="ident">Opsworkscm</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Organizations"><code class="name">var <span class="ident">Organizations</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Outposts"><code class="name">var <span class="ident">Outposts</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Panorama"><code class="name">var <span class="ident">Panorama</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Personalize"><code class="name">var <span class="ident">Personalize</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Personalize_Events"><code class="name">var <span class="ident">Personalize_Events</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Personalize_Runtime"><code class="name">var <span class="ident">Personalize_Runtime</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Pi"><code class="name">var <span class="ident">Pi</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Pinpoint"><code class="name">var <span class="ident">Pinpoint</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Pinpoint_Email"><code class="name">var <span class="ident">Pinpoint_Email</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Pinpoint_Sms_Voice"><code class="name">var <span class="ident">Pinpoint_Sms_Voice</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Pinpoint_Sms_Voice_V2"><code class="name">var <span class="ident">Pinpoint_Sms_Voice_V2</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Pipes"><code class="name">var <span class="ident">Pipes</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Polly"><code class="name">var <span class="ident">Polly</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Pricing"><code class="name">var <span class="ident">Pricing</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Privatenetworks"><code class="name">var <span class="ident">Privatenetworks</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Proton"><code class="name">var <span class="ident">Proton</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Qldb"><code class="name">var <span class="ident">Qldb</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Qldb_Session"><code class="name">var <span class="ident">Qldb_Session</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Quicksight"><code class="name">var <span class="ident">Quicksight</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Ram"><code class="name">var <span class="ident">Ram</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Rbin"><code class="name">var <span class="ident">Rbin</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Rds"><code class="name">var <span class="ident">Rds</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Rds_Data"><code class="name">var <span class="ident">Rds_Data</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Redshift"><code class="name">var <span class="ident">Redshift</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Redshift_Data"><code class="name">var <span class="ident">Redshift_Data</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Redshift_Serverless"><code class="name">var <span class="ident">Redshift_Serverless</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Rekognition"><code class="name">var <span class="ident">Rekognition</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Resiliencehub"><code class="name">var <span class="ident">Resiliencehub</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.ResourceGroupStaggingApi"><code class="name">var <span class="ident">ResourceGroupStaggingApi</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Resource_Explorer_2"><code class="name">var <span class="ident">Resource_Explorer_2</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Resource_Groups"><code class="name">var <span class="ident">Resource_Groups</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Robomaker"><code class="name">var <span class="ident">Robomaker</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Rolesanywhere"><code class="name">var <span class="ident">Rolesanywhere</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Route53"><code class="name">var <span class="ident">Route53</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Route53Domains"><code class="name">var <span class="ident">Route53Domains</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Route53Resolver"><code class="name">var <span class="ident">Route53Resolver</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Route53_Recovery_Cluster"><code class="name">var <span class="ident">Route53_Recovery_Cluster</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Route53_Recovery_Control_Config"><code class="name">var <span class="ident">Route53_Recovery_Control_Config</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Route53_Recovery_Readiness"><code class="name">var <span class="ident">Route53_Recovery_Readiness</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Rum"><code class="name">var <span class="ident">Rum</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.S3"><code class="name">var <span class="ident">S3</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.S3Control"><code class="name">var <span class="ident">S3Control</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.S3Outposts"><code class="name">var <span class="ident">S3Outposts</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Sagemaker"><code class="name">var <span class="ident">Sagemaker</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Sagemaker_A2I_Runtime"><code class="name">var <span class="ident">Sagemaker_A2I_Runtime</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Sagemaker_Edge"><code class="name">var <span class="ident">Sagemaker_Edge</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Sagemaker_Featurestore_Runtime"><code class="name">var <span class="ident">Sagemaker_Featurestore_Runtime</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Sagemaker_Geospatial"><code class="name">var <span class="ident">Sagemaker_Geospatial</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Sagemaker_Metrics"><code class="name">var <span class="ident">Sagemaker_Metrics</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Sagemaker_Runtime"><code class="name">var <span class="ident">Sagemaker_Runtime</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.SavingsPlans"><code class="name">var <span class="ident">SavingsPlans</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Scheduler"><code class="name">var <span class="ident">Scheduler</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Schemas"><code class="name">var <span class="ident">Schemas</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Sdb"><code class="name">var <span class="ident">Sdb</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Secretsmanager"><code class="name">var <span class="ident">Secretsmanager</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Securityhub"><code class="name">var <span class="ident">Securityhub</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Securitylake"><code class="name">var <span class="ident">Securitylake</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Serverlessrepo"><code class="name">var <span class="ident">Serverlessrepo</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.ServiceCatalog"><code class="name">var <span class="ident">ServiceCatalog</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.ServiceCatalog_Appregistry"><code class="name">var <span class="ident">ServiceCatalog_Appregistry</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.ServiceDiscovery"><code class="name">var <span class="ident">ServiceDiscovery</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Service_Quotas"><code class="name">var <span class="ident">Service_Quotas</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Ses"><code class="name">var <span class="ident">Ses</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Sesv2"><code class="name">var <span class="ident">Sesv2</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Shield"><code class="name">var <span class="ident">Shield</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Signer"><code class="name">var <span class="ident">Signer</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Simspaceweaver"><code class="name">var <span class="ident">Simspaceweaver</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Sms"><code class="name">var <span class="ident">Sms</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Sms_Voice"><code class="name">var <span class="ident">Sms_Voice</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Snow_Device_Management"><code class="name">var <span class="ident">Snow_Device_Management</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Snowball"><code class="name">var <span class="ident">Snowball</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Sns"><code class="name">var <span class="ident">Sns</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Sqs"><code class="name">var <span class="ident">Sqs</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Ssm"><code class="name">var <span class="ident">Ssm</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Ssm_Contacts"><code class="name">var <span class="ident">Ssm_Contacts</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Ssm_Incidents"><code class="name">var <span class="ident">Ssm_Incidents</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Ssm_Sap"><code class="name">var <span class="ident">Ssm_Sap</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Sso"><code class="name">var <span class="ident">Sso</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Sso_Admin"><code class="name">var <span class="ident">Sso_Admin</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Sso_Oidc"><code class="name">var <span class="ident">Sso_Oidc</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.StepFunctions"><code class="name">var <span class="ident">StepFunctions</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.StorageGateway"><code class="name">var <span class="ident">StorageGateway</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Sts"><code class="name">var <span class="ident">Sts</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Support"><code class="name">var <span class="ident">Support</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Support_App"><code class="name">var <span class="ident">Support_App</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Swf"><code class="name">var <span class="ident">Swf</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Synthetics"><code class="name">var <span class="ident">Synthetics</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Textract"><code class="name">var <span class="ident">Textract</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Timestream_Query"><code class="name">var <span class="ident">Timestream_Query</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Timestream_Write"><code class="name">var <span class="ident">Timestream_Write</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Transcribe"><code class="name">var <span class="ident">Transcribe</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Transfer"><code class="name">var <span class="ident">Transfer</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Translate"><code class="name">var <span class="ident">Translate</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Voice_Id"><code class="name">var <span class="ident">Voice_Id</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Waf"><code class="name">var <span class="ident">Waf</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Waf_Regional"><code class="name">var <span class="ident">Waf_Regional</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Wafv2"><code class="name">var <span class="ident">Wafv2</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.WellArchitected"><code class="name">var <span class="ident">WellArchitected</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Wisdom"><code class="name">var <span class="ident">Wisdom</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Workdocs"><code class="name">var <span class="ident">Workdocs</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Worklink"><code class="name">var <span class="ident">Worklink</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Workmail"><code class="name">var <span class="ident">Workmail</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.WorkmailMessageFlow"><code class="name">var <span class="ident">WorkmailMessageFlow</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Workspaces"><code class="name">var <span class="ident">Workspaces</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Workspaces_Web"><code class="name">var <span class="ident">Workspaces_Web</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.Xray"><code class="name">var <span class="ident">Xray</span> :Â Type[<a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.accessanalyzer"><code class="name">var <span class="ident">accessanalyzer</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.account"><code class="name">var <span class="ident">account</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.acm"><code class="name">var <span class="ident">acm</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.acm_pca"><code class="name">var <span class="ident">acm_pca</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.alexaforbusiness"><code class="name">var <span class="ident">alexaforbusiness</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.amp"><code class="name">var <span class="ident">amp</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.amplify"><code class="name">var <span class="ident">amplify</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.amplifybackend"><code class="name">var <span class="ident">amplifybackend</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.amplifyuibuilder"><code class="name">var <span class="ident">amplifyuibuilder</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.apigateway"><code class="name">var <span class="ident">apigateway</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.apigatewaymanagementapi"><code class="name">var <span class="ident">apigatewaymanagementapi</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.apigatewayv2"><code class="name">var <span class="ident">apigatewayv2</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.appconfig"><code class="name">var <span class="ident">appconfig</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.appconfigdata"><code class="name">var <span class="ident">appconfigdata</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.appflow"><code class="name">var <span class="ident">appflow</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.appintegrations"><code class="name">var <span class="ident">appintegrations</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.application_autoscaling"><code class="name">var <span class="ident">application_autoscaling</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.application_insights"><code class="name">var <span class="ident">application_insights</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.applicationcostprofiler"><code class="name">var <span class="ident">applicationcostprofiler</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.appmesh"><code class="name">var <span class="ident">appmesh</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.apprunner"><code class="name">var <span class="ident">apprunner</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.appstream"><code class="name">var <span class="ident">appstream</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.appsync"><code class="name">var <span class="ident">appsync</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.arc_zonal_shift"><code class="name">var <span class="ident">arc_zonal_shift</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.athena"><code class="name">var <span class="ident">athena</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.auditmanager"><code class="name">var <span class="ident">auditmanager</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.autoscaling"><code class="name">var <span class="ident">autoscaling</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.autoscaling_plans"><code class="name">var <span class="ident">autoscaling_plans</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.backup"><code class="name">var <span class="ident">backup</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.backup_gateway"><code class="name">var <span class="ident">backup_gateway</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.backupstorage"><code class="name">var <span class="ident">backupstorage</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.batch"><code class="name">var <span class="ident">batch</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.billingconductor"><code class="name">var <span class="ident">billingconductor</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.braket"><code class="name">var <span class="ident">braket</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.budgets"><code class="name">var <span class="ident">budgets</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.ce"><code class="name">var <span class="ident">ce</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.chime"><code class="name">var <span class="ident">chime</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.chime_sdk_identity"><code class="name">var <span class="ident">chime_sdk_identity</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.chime_sdk_media_pipelines"><code class="name">var <span class="ident">chime_sdk_media_pipelines</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.chime_sdk_meetings"><code class="name">var <span class="ident">chime_sdk_meetings</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.chime_sdk_messaging"><code class="name">var <span class="ident">chime_sdk_messaging</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.chime_sdk_voice"><code class="name">var <span class="ident">chime_sdk_voice</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.cleanrooms"><code class="name">var <span class="ident">cleanrooms</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.cloud9"><code class="name">var <span class="ident">cloud9</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.cloudcontrol"><code class="name">var <span class="ident">cloudcontrol</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.clouddirectory"><code class="name">var <span class="ident">clouddirectory</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.cloudformation"><code class="name">var <span class="ident">cloudformation</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.cloudfront"><code class="name">var <span class="ident">cloudfront</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.cloudhsm"><code class="name">var <span class="ident">cloudhsm</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.cloudhsmv2"><code class="name">var <span class="ident">cloudhsmv2</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.cloudsearch"><code class="name">var <span class="ident">cloudsearch</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.cloudsearchdomain"><code class="name">var <span class="ident">cloudsearchdomain</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.cloudtrail"><code class="name">var <span class="ident">cloudtrail</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.cloudtrail_data"><code class="name">var <span class="ident">cloudtrail_data</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.cloudwatch"><code class="name">var <span class="ident">cloudwatch</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.codeartifact"><code class="name">var <span class="ident">codeartifact</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.codebuild"><code class="name">var <span class="ident">codebuild</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.codecatalyst"><code class="name">var <span class="ident">codecatalyst</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.codecommit"><code class="name">var <span class="ident">codecommit</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.codedeploy"><code class="name">var <span class="ident">codedeploy</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.codeguru_reviewer"><code class="name">var <span class="ident">codeguru_reviewer</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.codeguruprofiler"><code class="name">var <span class="ident">codeguruprofiler</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.codepipeline"><code class="name">var <span class="ident">codepipeline</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.codestar"><code class="name">var <span class="ident">codestar</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.codestar_connections"><code class="name">var <span class="ident">codestar_connections</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.codestar_notifications"><code class="name">var <span class="ident">codestar_notifications</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.cognito_identity"><code class="name">var <span class="ident">cognito_identity</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.cognito_idp"><code class="name">var <span class="ident">cognito_idp</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.cognito_sync"><code class="name">var <span class="ident">cognito_sync</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.comprehend"><code class="name">var <span class="ident">comprehend</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.comprehendmedical"><code class="name">var <span class="ident">comprehendmedical</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.compute_optimizer"><code class="name">var <span class="ident">compute_optimizer</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.config"><code class="name">var <span class="ident">config</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.connect"><code class="name">var <span class="ident">connect</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.connect_contact_lens"><code class="name">var <span class="ident">connect_contact_lens</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.connectcampaigns"><code class="name">var <span class="ident">connectcampaigns</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.connectcases"><code class="name">var <span class="ident">connectcases</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.connectparticipant"><code class="name">var <span class="ident">connectparticipant</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.controltower"><code class="name">var <span class="ident">controltower</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.cur"><code class="name">var <span class="ident">cur</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.customer_profiles"><code class="name">var <span class="ident">customer_profiles</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.databrew"><code class="name">var <span class="ident">databrew</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.dataexchange"><code class="name">var <span class="ident">dataexchange</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.datapipeline"><code class="name">var <span class="ident">datapipeline</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.datasync"><code class="name">var <span class="ident">datasync</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.dax"><code class="name">var <span class="ident">dax</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.detective"><code class="name">var <span class="ident">detective</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.devicefarm"><code class="name">var <span class="ident">devicefarm</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.devops_guru"><code class="name">var <span class="ident">devops_guru</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.directconnect"><code class="name">var <span class="ident">directconnect</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.discovery"><code class="name">var <span class="ident">discovery</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.dlm"><code class="name">var <span class="ident">dlm</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.dms"><code class="name">var <span class="ident">dms</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.docdb"><code class="name">var <span class="ident">docdb</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.docdb_elastic"><code class="name">var <span class="ident">docdb_elastic</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.drs"><code class="name">var <span class="ident">drs</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.ds"><code class="name">var <span class="ident">ds</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.dynamodb"><code class="name">var <span class="ident">dynamodb</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.dynamodbstreams"><code class="name">var <span class="ident">dynamodbstreams</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.ebs"><code class="name">var <span class="ident">ebs</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.ec2"><code class="name">var <span class="ident">ec2</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.ec2_instance_connect"><code class="name">var <span class="ident">ec2_instance_connect</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.ecr"><code class="name">var <span class="ident">ecr</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.ecr_public"><code class="name">var <span class="ident">ecr_public</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.ecs"><code class="name">var <span class="ident">ecs</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.efs"><code class="name">var <span class="ident">efs</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.eks"><code class="name">var <span class="ident">eks</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.elastic_inference"><code class="name">var <span class="ident">elastic_inference</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.elasticache"><code class="name">var <span class="ident">elasticache</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.elasticbeanstalk"><code class="name">var <span class="ident">elasticbeanstalk</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.elastictranscoder"><code class="name">var <span class="ident">elastictranscoder</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.elb"><code class="name">var <span class="ident">elb</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.elbv2"><code class="name">var <span class="ident">elbv2</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.emr"><code class="name">var <span class="ident">emr</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.emr_containers"><code class="name">var <span class="ident">emr_containers</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.emr_serverless"><code class="name">var <span class="ident">emr_serverless</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.es"><code class="name">var <span class="ident">es</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.events"><code class="name">var <span class="ident">events</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.evidently"><code class="name">var <span class="ident">evidently</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.finspace"><code class="name">var <span class="ident">finspace</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.finspace_data"><code class="name">var <span class="ident">finspace_data</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.firehose"><code class="name">var <span class="ident">firehose</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.fis"><code class="name">var <span class="ident">fis</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.fms"><code class="name">var <span class="ident">fms</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.forecast"><code class="name">var <span class="ident">forecast</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.forecastquery"><code class="name">var <span class="ident">forecastquery</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.frauddetector"><code class="name">var <span class="ident">frauddetector</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.fsx"><code class="name">var <span class="ident">fsx</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.gamelift"><code class="name">var <span class="ident">gamelift</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.gamesparks"><code class="name">var <span class="ident">gamesparks</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.glacier"><code class="name">var <span class="ident">glacier</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.globalaccelerator"><code class="name">var <span class="ident">globalaccelerator</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.glue"><code class="name">var <span class="ident">glue</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.grafana"><code class="name">var <span class="ident">grafana</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.greengrass"><code class="name">var <span class="ident">greengrass</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.greengrassv2"><code class="name">var <span class="ident">greengrassv2</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.groundstation"><code class="name">var <span class="ident">groundstation</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.guardduty"><code class="name">var <span class="ident">guardduty</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.health"><code class="name">var <span class="ident">health</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.healthlake"><code class="name">var <span class="ident">healthlake</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.honeycode"><code class="name">var <span class="ident">honeycode</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.iam"><code class="name">var <span class="ident">iam</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.identitystore"><code class="name">var <span class="ident">identitystore</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.imagebuilder"><code class="name">var <span class="ident">imagebuilder</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.importexport"><code class="name">var <span class="ident">importexport</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.inspector"><code class="name">var <span class="ident">inspector</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.inspector2"><code class="name">var <span class="ident">inspector2</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.iot"><code class="name">var <span class="ident">iot</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.iot1click_devices"><code class="name">var <span class="ident">iot1click_devices</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.iot1click_projects"><code class="name">var <span class="ident">iot1click_projects</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.iot_data"><code class="name">var <span class="ident">iot_data</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.iot_jobs_data"><code class="name">var <span class="ident">iot_jobs_data</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.iot_roborunner"><code class="name">var <span class="ident">iot_roborunner</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.iotanalytics"><code class="name">var <span class="ident">iotanalytics</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.iotdeviceadvisor"><code class="name">var <span class="ident">iotdeviceadvisor</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.iotevents"><code class="name">var <span class="ident">iotevents</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.iotevents_data"><code class="name">var <span class="ident">iotevents_data</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.iotfleethub"><code class="name">var <span class="ident">iotfleethub</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.iotfleetwise"><code class="name">var <span class="ident">iotfleetwise</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.iotsecuretunneling"><code class="name">var <span class="ident">iotsecuretunneling</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.iotsitewise"><code class="name">var <span class="ident">iotsitewise</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.iotthingsgraph"><code class="name">var <span class="ident">iotthingsgraph</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.iottwinmaker"><code class="name">var <span class="ident">iottwinmaker</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.iotwireless"><code class="name">var <span class="ident">iotwireless</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.ivs"><code class="name">var <span class="ident">ivs</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.ivschat"><code class="name">var <span class="ident">ivschat</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.kafka"><code class="name">var <span class="ident">kafka</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.kafkaconnect"><code class="name">var <span class="ident">kafkaconnect</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.kendra"><code class="name">var <span class="ident">kendra</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.kendra_ranking"><code class="name">var <span class="ident">kendra_ranking</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.keyspaces"><code class="name">var <span class="ident">keyspaces</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.kinesis"><code class="name">var <span class="ident">kinesis</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.kinesis_video_archived_media"><code class="name">var <span class="ident">kinesis_video_archived_media</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.kinesis_video_media"><code class="name">var <span class="ident">kinesis_video_media</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.kinesis_video_signaling"><code class="name">var <span class="ident">kinesis_video_signaling</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.kinesis_video_webrtc_storage"><code class="name">var <span class="ident">kinesis_video_webrtc_storage</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.kinesisanalytics"><code class="name">var <span class="ident">kinesisanalytics</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.kinesisanalyticsv2"><code class="name">var <span class="ident">kinesisanalyticsv2</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.kinesisvideo"><code class="name">var <span class="ident">kinesisvideo</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.kms"><code class="name">var <span class="ident">kms</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.lakeformation"><code class="name">var <span class="ident">lakeformation</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.lambda_"><code class="name">var <span class="ident">lambda_</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.lex_models"><code class="name">var <span class="ident">lex_models</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.lex_runtime"><code class="name">var <span class="ident">lex_runtime</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.lexv2_models"><code class="name">var <span class="ident">lexv2_models</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.lexv2_runtime"><code class="name">var <span class="ident">lexv2_runtime</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.license_manager"><code class="name">var <span class="ident">license_manager</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.license_manager_linux_subscriptions"><code class="name">var <span class="ident">license_manager_linux_subscriptions</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.license_manager_user_subscriptions"><code class="name">var <span class="ident">license_manager_user_subscriptions</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.lightsail"><code class="name">var <span class="ident">lightsail</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.location"><code class="name">var <span class="ident">location</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.logs"><code class="name">var <span class="ident">logs</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.lookoutequipment"><code class="name">var <span class="ident">lookoutequipment</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.lookoutmetrics"><code class="name">var <span class="ident">lookoutmetrics</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.lookoutvision"><code class="name">var <span class="ident">lookoutvision</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.m2"><code class="name">var <span class="ident">m2</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.machinelearning"><code class="name">var <span class="ident">machinelearning</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.macie"><code class="name">var <span class="ident">macie</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.macie2"><code class="name">var <span class="ident">macie2</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.managedblockchain"><code class="name">var <span class="ident">managedblockchain</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.marketplace_catalog"><code class="name">var <span class="ident">marketplace_catalog</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.marketplace_entitlement"><code class="name">var <span class="ident">marketplace_entitlement</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.marketplacecommerceanalytics"><code class="name">var <span class="ident">marketplacecommerceanalytics</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.mediaconnect"><code class="name">var <span class="ident">mediaconnect</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.mediaconvert"><code class="name">var <span class="ident">mediaconvert</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.medialive"><code class="name">var <span class="ident">medialive</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.mediapackage"><code class="name">var <span class="ident">mediapackage</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.mediapackage_vod"><code class="name">var <span class="ident">mediapackage_vod</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.mediastore"><code class="name">var <span class="ident">mediastore</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.mediastore_data"><code class="name">var <span class="ident">mediastore_data</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.mediatailor"><code class="name">var <span class="ident">mediatailor</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.memorydb"><code class="name">var <span class="ident">memorydb</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.meteringmarketplace"><code class="name">var <span class="ident">meteringmarketplace</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.mgh"><code class="name">var <span class="ident">mgh</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.mgn"><code class="name">var <span class="ident">mgn</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.migration_hub_refactor_spaces"><code class="name">var <span class="ident">migration_hub_refactor_spaces</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.migrationhub_config"><code class="name">var <span class="ident">migrationhub_config</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.migrationhuborchestrator"><code class="name">var <span class="ident">migrationhuborchestrator</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.migrationhubstrategy"><code class="name">var <span class="ident">migrationhubstrategy</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.mobile"><code class="name">var <span class="ident">mobile</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.mq"><code class="name">var <span class="ident">mq</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.mturk"><code class="name">var <span class="ident">mturk</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.mwaa"><code class="name">var <span class="ident">mwaa</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.neptune"><code class="name">var <span class="ident">neptune</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.network_firewall"><code class="name">var <span class="ident">network_firewall</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.networkmanager"><code class="name">var <span class="ident">networkmanager</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.nimble"><code class="name">var <span class="ident">nimble</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.oam"><code class="name">var <span class="ident">oam</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.omics"><code class="name">var <span class="ident">omics</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.opensearch"><code class="name">var <span class="ident">opensearch</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.opensearchserverless"><code class="name">var <span class="ident">opensearchserverless</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.opsworks"><code class="name">var <span class="ident">opsworks</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.opsworkscm"><code class="name">var <span class="ident">opsworkscm</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.organizations"><code class="name">var <span class="ident">organizations</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.outposts"><code class="name">var <span class="ident">outposts</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.panorama"><code class="name">var <span class="ident">panorama</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.personalize"><code class="name">var <span class="ident">personalize</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.personalize_events"><code class="name">var <span class="ident">personalize_events</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.personalize_runtime"><code class="name">var <span class="ident">personalize_runtime</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.pi"><code class="name">var <span class="ident">pi</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.pinpoint"><code class="name">var <span class="ident">pinpoint</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.pinpoint_email"><code class="name">var <span class="ident">pinpoint_email</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.pinpoint_sms_voice"><code class="name">var <span class="ident">pinpoint_sms_voice</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.pinpoint_sms_voice_v2"><code class="name">var <span class="ident">pinpoint_sms_voice_v2</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.pipes"><code class="name">var <span class="ident">pipes</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.polly"><code class="name">var <span class="ident">polly</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.pricing"><code class="name">var <span class="ident">pricing</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.privatenetworks"><code class="name">var <span class="ident">privatenetworks</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.proton"><code class="name">var <span class="ident">proton</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.qldb"><code class="name">var <span class="ident">qldb</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.qldb_session"><code class="name">var <span class="ident">qldb_session</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.quicksight"><code class="name">var <span class="ident">quicksight</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.ram"><code class="name">var <span class="ident">ram</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.rbin"><code class="name">var <span class="ident">rbin</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.rds"><code class="name">var <span class="ident">rds</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.rds_data"><code class="name">var <span class="ident">rds_data</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.redshift"><code class="name">var <span class="ident">redshift</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.redshift_data"><code class="name">var <span class="ident">redshift_data</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.redshift_serverless"><code class="name">var <span class="ident">redshift_serverless</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.rekognition"><code class="name">var <span class="ident">rekognition</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.resiliencehub"><code class="name">var <span class="ident">resiliencehub</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.resource_explorer_2"><code class="name">var <span class="ident">resource_explorer_2</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.resource_groups"><code class="name">var <span class="ident">resource_groups</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.resourcegroupstaggingapi"><code class="name">var <span class="ident">resourcegroupstaggingapi</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.robomaker"><code class="name">var <span class="ident">robomaker</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.rolesanywhere"><code class="name">var <span class="ident">rolesanywhere</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.route53"><code class="name">var <span class="ident">route53</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.route53_recovery_cluster"><code class="name">var <span class="ident">route53_recovery_cluster</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.route53_recovery_control_config"><code class="name">var <span class="ident">route53_recovery_control_config</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.route53_recovery_readiness"><code class="name">var <span class="ident">route53_recovery_readiness</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.route53domains"><code class="name">var <span class="ident">route53domains</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.route53resolver"><code class="name">var <span class="ident">route53resolver</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.rum"><code class="name">var <span class="ident">rum</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.s3"><code class="name">var <span class="ident">s3</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.s3control"><code class="name">var <span class="ident">s3control</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.s3outposts"><code class="name">var <span class="ident">s3outposts</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.sagemaker"><code class="name">var <span class="ident">sagemaker</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.sagemaker_a2i_runtime"><code class="name">var <span class="ident">sagemaker_a2i_runtime</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.sagemaker_edge"><code class="name">var <span class="ident">sagemaker_edge</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.sagemaker_featurestore_runtime"><code class="name">var <span class="ident">sagemaker_featurestore_runtime</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.sagemaker_geospatial"><code class="name">var <span class="ident">sagemaker_geospatial</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.sagemaker_metrics"><code class="name">var <span class="ident">sagemaker_metrics</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.sagemaker_runtime"><code class="name">var <span class="ident">sagemaker_runtime</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.savingsplans"><code class="name">var <span class="ident">savingsplans</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.scheduler"><code class="name">var <span class="ident">scheduler</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.schemas"><code class="name">var <span class="ident">schemas</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.sdb"><code class="name">var <span class="ident">sdb</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.secretsmanager"><code class="name">var <span class="ident">secretsmanager</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.securityhub"><code class="name">var <span class="ident">securityhub</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.securitylake"><code class="name">var <span class="ident">securitylake</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.serverlessrepo"><code class="name">var <span class="ident">serverlessrepo</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.service_quotas"><code class="name">var <span class="ident">service_quotas</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.servicecatalog"><code class="name">var <span class="ident">servicecatalog</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.servicecatalog_appregistry"><code class="name">var <span class="ident">servicecatalog_appregistry</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.servicediscovery"><code class="name">var <span class="ident">servicediscovery</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.ses"><code class="name">var <span class="ident">ses</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.sesv2"><code class="name">var <span class="ident">sesv2</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.shield"><code class="name">var <span class="ident">shield</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.signer"><code class="name">var <span class="ident">signer</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.simspaceweaver"><code class="name">var <span class="ident">simspaceweaver</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.sms"><code class="name">var <span class="ident">sms</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.sms_voice"><code class="name">var <span class="ident">sms_voice</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.snow_device_management"><code class="name">var <span class="ident">snow_device_management</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.snowball"><code class="name">var <span class="ident">snowball</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.sns"><code class="name">var <span class="ident">sns</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.sqs"><code class="name">var <span class="ident">sqs</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.ssm"><code class="name">var <span class="ident">ssm</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.ssm_contacts"><code class="name">var <span class="ident">ssm_contacts</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.ssm_incidents"><code class="name">var <span class="ident">ssm_incidents</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.ssm_sap"><code class="name">var <span class="ident">ssm_sap</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.sso"><code class="name">var <span class="ident">sso</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.sso_admin"><code class="name">var <span class="ident">sso_admin</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.sso_oidc"><code class="name">var <span class="ident">sso_oidc</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.stepfunctions"><code class="name">var <span class="ident">stepfunctions</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.storagegateway"><code class="name">var <span class="ident">storagegateway</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.sts"><code class="name">var <span class="ident">sts</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.support"><code class="name">var <span class="ident">support</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.support_app"><code class="name">var <span class="ident">support_app</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.swf"><code class="name">var <span class="ident">swf</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.synthetics"><code class="name">var <span class="ident">synthetics</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.textract"><code class="name">var <span class="ident">textract</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.timestream_query"><code class="name">var <span class="ident">timestream_query</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.timestream_write"><code class="name">var <span class="ident">timestream_write</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.transcribe"><code class="name">var <span class="ident">transcribe</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.transfer"><code class="name">var <span class="ident">transfer</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.translate"><code class="name">var <span class="ident">translate</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.voice_id"><code class="name">var <span class="ident">voice_id</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.waf"><code class="name">var <span class="ident">waf</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.waf_regional"><code class="name">var <span class="ident">waf_regional</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.wafv2"><code class="name">var <span class="ident">wafv2</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.wellarchitected"><code class="name">var <span class="ident">wellarchitected</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.wisdom"><code class="name">var <span class="ident">wisdom</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.workdocs"><code class="name">var <span class="ident">workdocs</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.worklink"><code class="name">var <span class="ident">worklink</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.workmail"><code class="name">var <span class="ident">workmail</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.workmailmessageflow"><code class="name">var <span class="ident">workmailmessageflow</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.workspaces"><code class="name">var <span class="ident">workspaces</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.workspaces_web"><code class="name">var <span class="ident">workspaces_web</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoClients.xray"><code class="name">var <span class="ident">xray</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="xboto.dependencies.BotoClients.__init_subclass__"><code class="name flex">
<span>def <span class="ident">__init_subclass__</span></span>(<span>thread_sharable=Default, attributes_to_skip_while_copying:Â Optional[Iterable[str]]Â =Â Default, **kwargs)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xinject.dependency.Dependency" href="../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></code>.<code><a title="xinject.dependency.Dependency.__init_subclass__" href="../xinject/dependency.html#xinject.dependency.Dependency.__init_subclass__">__init_subclass__</a></code>
</p>
<div class="desc inherited"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>thread_sharable</code></strong></dt>
<dd>If <code>False</code>: While a dependency is lazily auto-created, we will
ensure we do it per-thread, and not make it visible â€¦</dd>
</dl></div>
</dd>
<dt id="xboto.dependencies.BotoClients.grab"><code class="name flex">
<span>def <span class="ident">grab</span></span>(<span>) â€‘>Â ~T</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xinject.dependency.Dependency" href="../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></code>.<code><a title="xinject.dependency.Dependency.grab" href="../xinject/dependency.html#xinject.dependency.Dependency.grab">grab</a></code>
</p>
<div class="desc inherited"><p>Gets a potentially shared dependency from the current <code>udpend.context.XContext</code> â€¦</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.proxy"><code class="name flex">
<span>def <span class="ident">proxy</span></span>(<span>) â€‘>Â ~R</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xinject.dependency.Dependency" href="../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></code>.<code><a title="xinject.dependency.Dependency.proxy" href="../xinject/dependency.html#xinject.dependency.Dependency.proxy">proxy</a></code>
</p>
<div class="desc inherited"><p>Returns a proxy-object, that when and attribute is asked for, it will
proxy it to the current object of <code>cls</code> â€¦</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.proxy_attribute"><code class="name flex">
<span>def <span class="ident">proxy_attribute</span></span>(<span>attribute_name:Â str) â€‘>Â Any</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xinject.dependency.Dependency" href="../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></code>.<code><a title="xinject.dependency.Dependency.proxy_attribute" href="../xinject/dependency.html#xinject.dependency.Dependency.proxy_attribute">proxy_attribute</a></code>
</p>
<div class="desc inherited"><p>Returns a proxy-object, that when and attribute is asked for, it will
proxy it to the current attribute value on the current object of <code>cls</code> â€¦</p></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="xboto.dependencies.BotoClients.obj"><code class="name">var <span class="ident">obj</span> :Â <a title="xinject.dependency.Dependency" href="../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xinject.dependency.Dependency" href="../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></code>.<code><a title="xinject.dependency.Dependency.obj" href="../xinject/dependency.html#xinject.dependency.Dependency.obj">obj</a></code>
</p>
<div class="desc inherited"><p>class property/attribute that will return the current dependency for the subclass
it's asked on by calling <code>Dependency.grab</code>, passing no extra â€¦</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="xboto.dependencies.BotoClients.__call__"><code class="name flex">
<span>def <span class="ident">__call__</span></span>(<span>self, func)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xinject.dependency.Dependency" href="../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></code>.<code><a title="xinject.dependency.Dependency.__call__" href="../xinject/dependency.html#xinject.dependency.Dependency.__call__">__call__</a></code>
</p>
<div class="desc inherited"><p>This makes Resource subclasses have an ability to be used as function decorators
by default unless this method is overriden to provide some other â€¦</p></div>
</dd>
<dt id="xboto.dependencies.BotoClients.__copy__"><code class="name flex">
<span>def <span class="ident">__copy__</span></span>(<span>self)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xinject.dependency.Dependency" href="../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></code>.<code><a title="xinject.dependency.Dependency.__copy__" href="../xinject/dependency.html#xinject.dependency.Dependency.__copy__">__copy__</a></code>
</p>
<div class="desc inherited"><p>Basic shallow copy protection
(I am wondering if I should just remove this default copy code) â€¦</p></div>
</dd>
</dl>
</dd>
<dt id="xboto.dependencies.BotoResource"><code class="flex name class">
<span>class <span class="ident">BotoResource</span></span>
<span>(</span><span>region_name=None, api_version=None, use_ssl=None, verify=None, endpoint_url=None, aws_access_key_id=None, aws_secret_access_key=None, aws_session_token=None, config=None, **boto_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p>
<p>You can specify any of the boto client/resource args, the known ones have been
specififed and documented out.</p>
<p>If there are ones in the future that are new or we don't know about, you can
still specify them, they will be passed to us in <code>boto_kwargs</code>, which will be
used as addtional kwargs when creating new boto client/resource.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>region_name</code></strong></dt>
<dd>The name of the region associated with the client. A client is associated
with a single region.</dd>
<dt><strong><code>api_version</code></strong></dt>
<dd>The API version to use. By default, botocore will use the latest API
version when creating a client.You only need to specify this parameter if you want
to use a previous API version of the client.</dd>
<dt><strong><code>use_ssl</code></strong></dt>
<dd>Whether or not to use SSL. By default, SSL is used. Note that not all
services support non-ssl connections.</dd>
<dt><strong><code>verify</code></strong></dt>
<dd>
<p>Whether or not to verify SSL certificates. By default SSL certificates are
verified. You can provide the following values:</p>
<ul>
<li>False - do not validate SSL certificates. SSL will still be used
(unless use_ssl is False), but SSL certificates will not be verified.</li>
<li>path/to/cert/bundle.pem - A filename of the CA cert bundle to uses.
You can specify this argument if you want to use a different CA cert bundle
than the one used by botocore.</li>
</ul>
</dd>
<dt><strong><code>endpoint_url</code></strong></dt>
<dd>The complete URL to use for the constructed client.
Normally, botocore will automatically construct the appropriate URL to use when
communicating with a service. You can specify a complete URL
(including the "http/https" scheme) to override this behavior.
If this value is provided, then use_ssl is ignored.</dd>
<dt><strong><code>aws_access_key_id</code></strong></dt>
<dd>The access key to use when creating the client.
This is entirely optional, and if not provided, the credentials configured for the
session will automatically be used. You only need to provide this argument if you
want to override the credentials used for this specific client.</dd>
<dt><strong><code>aws_secret_access_key</code></strong></dt>
<dd>The secret key to use when creating the client.
Same semantics as aws_access_key_id above.</dd>
<dt><strong><code>aws_session_token</code></strong></dt>
<dd>The session token to use when creating the client.
Same semantics as aws_access_key_id above.</dd>
<dt><strong><code>config</code></strong></dt>
<dd>Advanced client configuration options.
If region_name is specified in the client config, its value will take precedence
over environment variables and configuration values, but not over a region_name
value passed explicitly to the method. If user_agent_extra is specified in the
client config, it overrides the default user_agent_extra provided by the resource
API. See
<a href="https://botocore.amazonaws.com/v1/documentation/api/latest/reference/config.html">botocore config documentation</a>
for more details.</dd>
</dl>
<p>**boto_kwargs:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BotoResource(_BaseBotoClientOrResource, boto_kind=&#39;resource&#39;):
    @property
    def boto_resource(self):
        return self.get()

    @classmethod
    def get_dependency_cls(cls, boto_name: str) -&gt; &#39;Type[BotoResource]&#39;:
        return cls._get_dependency_cls(boto_name)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>xboto.dependencies._BaseBotoClientOrResource</li>
<li><a title="xinject.dependency.Dependency" href="../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>xboto.dependencies.CloudformationResource</li>
<li>xboto.dependencies.CloudwatchResource</li>
<li>xboto.dependencies.DynamodbResource</li>
<li>xboto.dependencies.Ec2Resource</li>
<li>xboto.dependencies.GlacierResource</li>
<li>xboto.dependencies.IamResource</li>
<li>xboto.dependencies.NsResource</li>
<li>xboto.dependencies.OpsworksResource</li>
<li>xboto.dependencies.S3Resource</li>
<li>xboto.dependencies.SqsResource</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="xboto.dependencies.BotoResource.__init_subclass__"><code class="name flex">
<span>def <span class="ident">__init_subclass__</span></span>(<span>thread_sharable=Default, attributes_to_skip_while_copying:Â Optional[Iterable[str]]Â =Â Default, **kwargs)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xinject.dependency.Dependency" href="../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></code>.<code><a title="xinject.dependency.Dependency.__init_subclass__" href="../xinject/dependency.html#xinject.dependency.Dependency.__init_subclass__">__init_subclass__</a></code>
</p>
<div class="desc inherited"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>thread_sharable</code></strong></dt>
<dd>If <code>False</code>: While a dependency is lazily auto-created, we will
ensure we do it per-thread, and not make it visible â€¦</dd>
</dl></div>
</dd>
<dt id="xboto.dependencies.BotoResource.get_dependency_cls"><code class="name flex">
<span>def <span class="ident">get_dependency_cls</span></span>(<span>boto_name:Â str) â€‘>Â Type[<a title="xboto.dependencies.BotoResource" href="#xboto.dependencies.BotoResource">BotoResource</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def get_dependency_cls(cls, boto_name: str) -&gt; &#39;Type[BotoResource]&#39;:
    return cls._get_dependency_cls(boto_name)</code></pre>
</details>
</dd>
<dt id="xboto.dependencies.BotoResource.grab"><code class="name flex">
<span>def <span class="ident">grab</span></span>(<span>) â€‘>Â ~T</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xinject.dependency.Dependency" href="../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></code>.<code><a title="xinject.dependency.Dependency.grab" href="../xinject/dependency.html#xinject.dependency.Dependency.grab">grab</a></code>
</p>
<div class="desc inherited"><p>Gets a potentially shared dependency from the current <code>udpend.context.XContext</code> â€¦</p></div>
</dd>
<dt id="xboto.dependencies.BotoResource.proxy"><code class="name flex">
<span>def <span class="ident">proxy</span></span>(<span>) â€‘>Â ~R</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xinject.dependency.Dependency" href="../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></code>.<code><a title="xinject.dependency.Dependency.proxy" href="../xinject/dependency.html#xinject.dependency.Dependency.proxy">proxy</a></code>
</p>
<div class="desc inherited"><p>Returns a proxy-object, that when and attribute is asked for, it will
proxy it to the current object of <code>cls</code> â€¦</p></div>
</dd>
<dt id="xboto.dependencies.BotoResource.proxy_attribute"><code class="name flex">
<span>def <span class="ident">proxy_attribute</span></span>(<span>attribute_name:Â str) â€‘>Â Any</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xinject.dependency.Dependency" href="../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></code>.<code><a title="xinject.dependency.Dependency.proxy_attribute" href="../xinject/dependency.html#xinject.dependency.Dependency.proxy_attribute">proxy_attribute</a></code>
</p>
<div class="desc inherited"><p>Returns a proxy-object, that when and attribute is asked for, it will
proxy it to the current attribute value on the current object of <code>cls</code> â€¦</p></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="xboto.dependencies.BotoResource.boto_resource"><code class="name">var <span class="ident">boto_resource</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def boto_resource(self):
    return self.get()</code></pre>
</details>
</dd>
<dt id="xboto.dependencies.BotoResource.obj"><code class="name">var <span class="ident">obj</span> :Â <a title="xinject.dependency.Dependency" href="../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xinject.dependency.Dependency" href="../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></code>.<code><a title="xinject.dependency.Dependency.obj" href="../xinject/dependency.html#xinject.dependency.Dependency.obj">obj</a></code>
</p>
<div class="desc inherited"><p>class property/attribute that will return the current dependency for the subclass
it's asked on by calling <code>Dependency.grab</code>, passing no extra â€¦</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="xboto.dependencies.BotoResource.__call__"><code class="name flex">
<span>def <span class="ident">__call__</span></span>(<span>self, func)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xinject.dependency.Dependency" href="../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></code>.<code><a title="xinject.dependency.Dependency.__call__" href="../xinject/dependency.html#xinject.dependency.Dependency.__call__">__call__</a></code>
</p>
<div class="desc inherited"><p>This makes Resource subclasses have an ability to be used as function decorators
by default unless this method is overriden to provide some other â€¦</p></div>
</dd>
<dt id="xboto.dependencies.BotoResource.__copy__"><code class="name flex">
<span>def <span class="ident">__copy__</span></span>(<span>self)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xinject.dependency.Dependency" href="../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></code>.<code><a title="xinject.dependency.Dependency.__copy__" href="../xinject/dependency.html#xinject.dependency.Dependency.__copy__">__copy__</a></code>
</p>
<div class="desc inherited"><p>Basic shallow copy protection
(I am wondering if I should just remove this default copy code) â€¦</p></div>
</dd>
</dl>
</dd>
<dt id="xboto.dependencies.BotoResources"><code class="flex name class">
<span>class <span class="ident">BotoResources</span></span>
</code></dt>
<dd>
<div class="desc"><p>When you get an attribute off of me, I'll attempt to ask the boto3 library to allocate
a resource of the same type, and then store itself, so I return the same resource again
in the future.</p>
<p>Right now, we will lazily allocate a boto3 resource per-thread, and we will use the
per-thread shared boto3 session resource to do it (ie: <code>_BotoSession.session</code>).</p>
<p>You can also easily import and use the <code><a title="xboto.dependencies.boto_resources" href="#xboto.dependencies.boto_resources">boto_resources</a></code> proxy object
(defined at top module-level).</p>
<p>You can use <code><a title="xboto.dependencies.boto_resources" href="#xboto.dependencies.boto_resources">boto_resources</a></code> exactly the same as using <code><a title="xboto.dependencies.BotoResources.grab" href="../xinject/dependency.html#xboto.dependencies.BotoResources.grab">Dependency.grab()</a></code>,
making it more convenient to use since you can directly import <code><a title="xboto.dependencies.boto_resources" href="#xboto.dependencies.boto_resources">boto_resources</a></code>.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xboto import boto_resources
&gt;&gt;&gt; # Showing here how you could use it to get a Table resource:
&gt;&gt;&gt; table = boto_resources.dynamodb.Table(&quot;some-table&quot;)
</code></pre>
<p>If you have an aws resource that uses a <code>-</code> for it's name, you can use an <code>_</code> (underscore)
instead.
All underscores are changed to a <code>-</code> when looking up the aws resource.
You can also directly use the <code>xboto.dependencies.BotoResources.load</code> method, and use a <code>-</code>
there.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BotoResources(_Loader, boto_dependency_class=BotoResource):
    &#34;&#34;&#34;
    When you get an attribute off of me, I&#39;ll attempt to ask the boto3 library to allocate
    a resource of the same type, and then store itself, so I return the same resource again
    in the future.

    Right now, we will lazily allocate a boto3 resource per-thread, and we will use the
    per-thread shared boto3 session resource to do it (ie: `_BotoSession.session`).

    You can also easily import and use the `boto_resources` proxy object
    (defined at top module-level).

    You can use `boto_resources` exactly the same as using `BotoResources.grab()`,
    making it more convenient to use since you can directly import `boto_resources`.

    &gt;&gt;&gt; from xboto import boto_resources
    &gt;&gt;&gt; # Showing here how you could use it to get a Table resource:
    &gt;&gt;&gt; table = boto_resources.dynamodb.Table(&#34;some-table&#34;)

    If you have an aws resource that uses a `-` for it&#39;s name, you can use an `_` (underscore)
    instead.
    All underscores are changed to a `-` when looking up the aws resource.
    You can also directly use the `xboto.dependencies.BotoResources.load` method, and use a `-`
    there.
    &#34;&#34;&#34;

    def _lookup(self, module, **kwargs):
        return BotoResource.get_dependency_cls(module).grab().boto_resource

    # These annotations are only for IDE-type-completion;
    # any client boto supports will work regardless (even if not listed below).
    #
    # These are the xyn-resource `Resource` types/classes; ie: BotoResource subclasses
    # (start with upper-case letter):
    DynamoDB: Type[BotoResource]
    CloudFormation: Type[BotoResource]
    CloudWatch: Type[BotoResource]
    Ec2: Type[BotoResource]
    Glacier: Type[BotoResource]
    Iam: Type[BotoResource]
    OpsWorks: Type[BotoResource]
    S3: Type[BotoResource]
    Ns: Type[BotoResource]
    Sqs: Type[BotoResource]

    # These annotations are only for IDE-type-completion;
    # any client boto supports will work regardless (even if not listed below).
    #
    # These are the boto resource objects (start with lower-case letter):
    dynamodb: Any
    cloudformation: Any
    cloudwatch: Any
    ec2: Any
    glacier: Any
    iam: Any
    opsworks: Any
    s3: Any
    ns: Any
    sqs: Any</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>xboto.dependencies._Loader</li>
<li><a title="xinject.dependency.Dependency" href="../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="xboto.dependencies.BotoResources.CloudFormation"><code class="name">var <span class="ident">CloudFormation</span> :Â Type[<a title="xboto.dependencies.BotoResource" href="#xboto.dependencies.BotoResource">BotoResource</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoResources.CloudWatch"><code class="name">var <span class="ident">CloudWatch</span> :Â Type[<a title="xboto.dependencies.BotoResource" href="#xboto.dependencies.BotoResource">BotoResource</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoResources.DynamoDB"><code class="name">var <span class="ident">DynamoDB</span> :Â Type[<a title="xboto.dependencies.BotoResource" href="#xboto.dependencies.BotoResource">BotoResource</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoResources.Ec2"><code class="name">var <span class="ident">Ec2</span> :Â Type[<a title="xboto.dependencies.BotoResource" href="#xboto.dependencies.BotoResource">BotoResource</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoResources.Glacier"><code class="name">var <span class="ident">Glacier</span> :Â Type[<a title="xboto.dependencies.BotoResource" href="#xboto.dependencies.BotoResource">BotoResource</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoResources.Iam"><code class="name">var <span class="ident">Iam</span> :Â Type[<a title="xboto.dependencies.BotoResource" href="#xboto.dependencies.BotoResource">BotoResource</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoResources.Ns"><code class="name">var <span class="ident">Ns</span> :Â Type[<a title="xboto.dependencies.BotoResource" href="#xboto.dependencies.BotoResource">BotoResource</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoResources.OpsWorks"><code class="name">var <span class="ident">OpsWorks</span> :Â Type[<a title="xboto.dependencies.BotoResource" href="#xboto.dependencies.BotoResource">BotoResource</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoResources.S3"><code class="name">var <span class="ident">S3</span> :Â Type[<a title="xboto.dependencies.BotoResource" href="#xboto.dependencies.BotoResource">BotoResource</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoResources.Sqs"><code class="name">var <span class="ident">Sqs</span> :Â Type[<a title="xboto.dependencies.BotoResource" href="#xboto.dependencies.BotoResource">BotoResource</a>]</code></dt>
<dd>
<div class="desc"><p>If you have not already done so, you should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for an overview
of the library before diving into the below text, that's more of like reference material.</p>
<h2 id="summary">Summary</h2>
<p>Allows you to create subclasses that act as sharable dependencies.
Things that should stick around and should be created lazily.</p>
<p>Also allows code to temporarily create, customize and activate a dependency if you don't want
the customization to stick around permanently.
You can do it without your or other code needing to be aware of each other.</p>
<p>This helps promote code decoupling, since it's so easy to make a Resource activate it
as the 'current' version to use.</p>
<p>The only coupling that takes place is to the Resource sub-class it's self.</p>
<p>You can also easily have each thread lazily create seperate instance of your Resource,
by inheriting from <code>PerThreadResource</code>.</p>
<p>Each separate piece of code that uses a particular Resource subclass can be completely
unaware of each other, and yet each one can take advantage of the shared dependency.</p>
<p>This means that Resource can help cover dependency-injection use-cases.</p>
<h2 id="overview">Overview</h2>
<p>A <code>Resource</code> represents an object in a <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
Generally, dependencies that are added/created inside a <code>XContext</code> inherit from this abstract
base <code>Resource</code> class, but are not required too. <code>Resource</code> just adds some class-level
conveince methods and configuratino options. Inheriting from Resource also helps
self-document that it's a Resource.</p>
<p>See <a href="#dependencies">Resources</a> at top of this module for a general overview of how dependencies
and <code>XContext</code>'s work. You should also read the xinject project's
<a href="https://github.com/xyngular/py-xinject#documentation">README.md</a> for a high-level
overview.
The text below is more like plain refrence matrial.</p>
<p>Get the current dependency via <code>Resource.dependency</code>, you can call it on sub-class/concreate
dependency type, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject import Dependency
&gt;&gt;&gt; class MyConfig(Dependency):
...     some_setting: str = &quot;default-setting-string&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; MyConfig.grab().some_setting
</code></pre>
<p>By default, Resource's act like a singletons; in that child contexs will simply get the same
instance of the dependency that the parent context has.</p>
<p>If you inherit from this class, when you have <code>Resource.dependency</code> called on you,
we will do our best to ensure that the same object instance is returned every time
(there are two exceptions, keep reading).</p>
<p>These dependencies are stored in the current <code>XContext</code>'s parent.
What happens is:</p>
<p>If the current <code>XContext</code> and none of their parents have this object and it's asked for
(like what happens when <code>Resource.dependency</code> is called on it),
it will be created in the deepest/oldest parent XContext.</p>
<p>This is the first parent <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code> who's <code>XContext.parent</code> is None.
That way it should be visible to everyone on the current thread since it will normally be
created in the app-root <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.</p>
<p>If the Dependency can't be shared between multiple threads, creation would normally happen
at the thread-root XContext instead of the app-root one.</p>
<p>If we don't already exist in any parent, then we must be created the first time we are asked
for. Normally it will simply be a direct call the dependency-type being requested,
this is the normal way to create objects in python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyResource(Dependency):
&gt;&gt;&gt;     pass
&gt;&gt;&gt;
&gt;&gt;&gt; MyResource.grab()
</code></pre>
<p>When that last line is executed, and the current or any parent context has a <code>MyResource</code>
dependency; <code>XContext</code> will simply create one via calling the dependency type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyResource()
</code></pre>
<p>You can allocate the dependency yourself with custom options and add it to the XContext your
self.</p>
<p>Here are the various ways to do that, via:</p>
<ul>
<li>
<p><code>XContext.add</code>
Adds dependency to a specific XContext that already exists
(or replaces if one has already been directly added in the past to that specific Context).
When/While XContext is active, these added dependencies will be the <code>current</code> ones.</p>
</li>
<li>
<p>Decorator, ie: <code>@MyResource()</code></p>
<pre><code>&gt;&gt;&gt; from xny_config import Config, config
&gt;&gt;&gt;
&gt;&gt;&gt; @DependencySubclass(service="override-service-name")
&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>via a with statement.</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;    with @DependencySubclass(service="override-service-name")
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
<li>
<p>multiple in single statement by making your own XContext directly:</p>
<pre><code>&gt;&gt;&gt; def my_method():
&gt;&gt;&gt;     with @XContext([
&gt;&gt;&gt;         DependencySubclass(service="override-service-name"),
&gt;&gt;&gt;         SomeOtherDep(name='new-name')
&gt;&gt;&gt;     ]):
&gt;&gt;&gt;         assert config.service == "override-service-name"
</code></pre>
</li>
</ul>
<h2 id="background-on-unit-testing">Background on Unit Testing</h2>
<p>By default, unit tests always create a new blank <code>XContext</code> with <code>parent=None</code>.
THis is done by an autouse fixture (<code><a title="xinject.pytest_plugin.xinject_test_context" href="../xinject/pytest_plugin.html#xinject.pytest_plugin.xinject_test_context">xinject_test_context()</a></code>)
THis forces every unit test run to create new dependencies when they are asked for (lazily).</p>
<p>This fixture is used automatically for each unit test, it clears the app-root XContext,
removes all current thread-root XContext's and their children from being <code>active</code>.
just beofre each run of a unit test.</p>
<p>That way it will recreate any shared dependency each time and a unit test can't leak
dependencies it added or changed into the next run.</p>
<p>One example of why this is good is for <code>moto</code> when mocking dynamodb in boto3 client.
Can use dependency to ensure that we get a new dynamodb shared dependency for <code>boto</code> each time
a unit test executes
(which helps with <code>moto</code>, it needs to be active when a dependency is allocated/used).</p>
<p>This is exactly what we want for each unit test run, to have a blank-slate for all the
vairous dependencies.</p>
<p>If a particulre set of unit-tests need to have specific dependcies, you can use fixtures to
modify/add various dependcies as needed for each indivirual unit-test function run.</p>
<p>When the application runs for real though, we do generally want to use the dependencies in a
shared fashion.
So normally we only allocate a new blank-root <code>@XContext(parent=None)</code>
either at the start of a normal application run, or during a unit-test.</p></div>
</dd>
<dt id="xboto.dependencies.BotoResources.cloudformation"><code class="name">var <span class="ident">cloudformation</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoResources.cloudwatch"><code class="name">var <span class="ident">cloudwatch</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoResources.dynamodb"><code class="name">var <span class="ident">dynamodb</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoResources.ec2"><code class="name">var <span class="ident">ec2</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoResources.glacier"><code class="name">var <span class="ident">glacier</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoResources.iam"><code class="name">var <span class="ident">iam</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoResources.ns"><code class="name">var <span class="ident">ns</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoResources.opsworks"><code class="name">var <span class="ident">opsworks</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoResources.s3"><code class="name">var <span class="ident">s3</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xboto.dependencies.BotoResources.sqs"><code class="name">var <span class="ident">sqs</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="xboto.dependencies.BotoResources.__init_subclass__"><code class="name flex">
<span>def <span class="ident">__init_subclass__</span></span>(<span>thread_sharable=Default, attributes_to_skip_while_copying:Â Optional[Iterable[str]]Â =Â Default, **kwargs)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xinject.dependency.Dependency" href="../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></code>.<code><a title="xinject.dependency.Dependency.__init_subclass__" href="../xinject/dependency.html#xinject.dependency.Dependency.__init_subclass__">__init_subclass__</a></code>
</p>
<div class="desc inherited"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>thread_sharable</code></strong></dt>
<dd>If <code>False</code>: While a dependency is lazily auto-created, we will
ensure we do it per-thread, and not make it visible â€¦</dd>
</dl></div>
</dd>
<dt id="xboto.dependencies.BotoResources.grab"><code class="name flex">
<span>def <span class="ident">grab</span></span>(<span>) â€‘>Â ~T</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xinject.dependency.Dependency" href="../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></code>.<code><a title="xinject.dependency.Dependency.grab" href="../xinject/dependency.html#xinject.dependency.Dependency.grab">grab</a></code>
</p>
<div class="desc inherited"><p>Gets a potentially shared dependency from the current <code>udpend.context.XContext</code> â€¦</p></div>
</dd>
<dt id="xboto.dependencies.BotoResources.proxy"><code class="name flex">
<span>def <span class="ident">proxy</span></span>(<span>) â€‘>Â ~R</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xinject.dependency.Dependency" href="../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></code>.<code><a title="xinject.dependency.Dependency.proxy" href="../xinject/dependency.html#xinject.dependency.Dependency.proxy">proxy</a></code>
</p>
<div class="desc inherited"><p>Returns a proxy-object, that when and attribute is asked for, it will
proxy it to the current object of <code>cls</code> â€¦</p></div>
</dd>
<dt id="xboto.dependencies.BotoResources.proxy_attribute"><code class="name flex">
<span>def <span class="ident">proxy_attribute</span></span>(<span>attribute_name:Â str) â€‘>Â Any</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xinject.dependency.Dependency" href="../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></code>.<code><a title="xinject.dependency.Dependency.proxy_attribute" href="../xinject/dependency.html#xinject.dependency.Dependency.proxy_attribute">proxy_attribute</a></code>
</p>
<div class="desc inherited"><p>Returns a proxy-object, that when and attribute is asked for, it will
proxy it to the current attribute value on the current object of <code>cls</code> â€¦</p></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="xboto.dependencies.BotoResources.obj"><code class="name">var <span class="ident">obj</span> :Â <a title="xinject.dependency.Dependency" href="../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xinject.dependency.Dependency" href="../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></code>.<code><a title="xinject.dependency.Dependency.obj" href="../xinject/dependency.html#xinject.dependency.Dependency.obj">obj</a></code>
</p>
<div class="desc inherited"><p>class property/attribute that will return the current dependency for the subclass
it's asked on by calling <code>Dependency.grab</code>, passing no extra â€¦</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="xboto.dependencies.BotoResources.__call__"><code class="name flex">
<span>def <span class="ident">__call__</span></span>(<span>self, func)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xinject.dependency.Dependency" href="../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></code>.<code><a title="xinject.dependency.Dependency.__call__" href="../xinject/dependency.html#xinject.dependency.Dependency.__call__">__call__</a></code>
</p>
<div class="desc inherited"><p>This makes Resource subclasses have an ability to be used as function decorators
by default unless this method is overriden to provide some other â€¦</p></div>
</dd>
<dt id="xboto.dependencies.BotoResources.__copy__"><code class="name flex">
<span>def <span class="ident">__copy__</span></span>(<span>self)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xinject.dependency.Dependency" href="../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></code>.<code><a title="xinject.dependency.Dependency.__copy__" href="../xinject/dependency.html#xinject.dependency.Dependency.__copy__">__copy__</a></code>
</p>
<div class="desc inherited"><p>Basic shallow copy protection
(I am wondering if I should just remove this default copy code) â€¦</p></div>
</dd>
</dl>
</dd>
<dt id="xboto.dependencies.BotoSession"><code class="flex name class">
<span>class <span class="ident">BotoSession</span></span>
<span>(</span><span>*, reset_session_when_activated=False, aws_access_key_id:Â Optional[str]Â =Â None, aws_secret_access_key:Â Optional[str]Â =Â None, aws_session_token:Â Optional[str]Â =Â None, region_name:Â Optional[str]Â =Â None, botocore_session:Â Optional[botocore.session.Session]Â =Â None, profile_name:Â Optional[str]Â =Â None, **session_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>You can use this as an easy way to get a shared boto-session for the current thread.</p>
<p>Right now only used with <code>_Loader</code> subclasses such as <code><a title="xboto.dependencies.BotoClients" href="#xboto.dependencies.BotoClients">BotoClients</a></code> and <code><a title="xboto.dependencies.BotoResources" href="#xboto.dependencies.BotoResources">BotoResources</a></code>.</p>
<p>Boto Sessions are NOT thread-safe.
When user is not using a session to create a client/resource,
boto3 uses an internal/default session instead which is not thread-safe.</p>
<ul>
<li>Or the docs for boto about this:<ul>
<li><a href="https://boto3.amazonaws.com/v1/documentation/api/latest/guide/session.html">https://boto3.amazonaws.com/v1/documentation/api/latest/guide/session.html</a></li>
</ul>
</li>
<li>For various examples see issue where people talk about it:<ul>
<li><a href="https://github.com/boto/botocore/issues/1246">https://github.com/boto/botocore/issues/1246</a></li>
</ul>
</li>
</ul>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>reset_session_when_activated</code></strong></dt>
<dd>
<p>If True: when self is activated
(ie: made the current resource/dependency)
will automatically call <code><a title="xboto.dependencies.BotoSession.reset_session" href="#xboto.dependencies.BotoSession.reset_session">BotoSession.reset_session()</a></code>, and therefore next time
<code><a title="xboto.dependencies.BotoSession.session" href="#xboto.dependencies.BotoSession.session">BotoSession.session</a></code> is asked for will lazily allocate new boto Session.
This is useful for unit-tests, where you really do want to create a new
session/connection each time the unit-test is called if you use
<code><a title="xboto.dependencies.BotoSession" href="#xboto.dependencies.BotoSession">BotoSession</a></code> as a decorator to a unit-testing method.</p>
<p>If False (default): will keep any session that has been previously/lazily created.
This keeps the connections around for you; hence why it's the default option.</p>
</dd>
<dt><strong><code>aws_access_key_id</code></strong> :&ensp;<code>str</code></dt>
<dd>access key ID</dd>
<dt><strong><code>aws_secret_access_key</code></strong> :&ensp;<code>str</code></dt>
<dd>AWS secret access key</dd>
<dt><strong><code>aws_session_token</code></strong> :&ensp;<code>str</code></dt>
<dd>AWS temporary session token</dd>
<dt><strong><code>region_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Default region when creating new connections</dd>
<dt><strong><code>botocore_session</code></strong> :&ensp;<code>botocore.session.Session</code></dt>
<dd>Use this Botocore session instead of
creating a new default one.</dd>
<dt><strong><code>profile_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of a profile to use. If not given, then the default
profile is used.</dd>
<dt><strong><code>**session_kwargs</code></strong></dt>
<dd>Pass additional args for boto Session here
(for additional args that boto3 might add in the future).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BotoSession(Dependency):
    &#34;&#34;&#34;
    You can use this as an easy way to get a shared boto-session for the current thread.

    Right now only used with `_Loader` subclasses such as `BotoClients` and `BotoResources`.

    Boto Sessions are NOT thread-safe.
    When user is not using a session to create a client/resource,
    boto3 uses an internal/default session instead which is not thread-safe.

    - Or the docs for boto about this:
        - https://boto3.amazonaws.com/v1/documentation/api/latest/guide/session.html
    - For various examples see issue where people talk about it:
        - https://github.com/boto/botocore/issues/1246
    &#34;&#34;&#34;

    @property
    def session(self) -&gt; boto3.Session:
        if session := self._session:
            return session
        session = boto3.Session(**self._session_kwargs)
        self._session = session
        return session

    def __init__(
            self, *,
            reset_session_when_activated=False,
            aws_access_key_id: Optional[str] = None,
            aws_secret_access_key: Optional[str] = None,
            aws_session_token: Optional[str] = None,
            region_name: Optional[str] = None,
            botocore_session: Optional[Session] = None,
            profile_name: Optional[str] = None,
            **session_kwargs
    ):
        &#34;&#34;&#34;

        Args:
            reset_session_when_activated: If True: when self is activated
                (ie: made the current resource/dependency)
                will automatically call `BotoSession.reset_session()`, and therefore next time
                `BotoSession.session` is asked for will lazily allocate new boto Session.
                This is useful for unit-tests, where you really do want to create a new
                session/connection each time the unit-test is called if you use
                `BotoSession` as a decorator to a unit-testing method.

                If False (default): will keep any session that has been previously/lazily created.
                This keeps the connections around for you; hence why it&#39;s the default option.

            aws_access_key_id (str):  access key ID
            aws_secret_access_key (str): AWS secret access key
            aws_session_token (str): AWS temporary session token
            region_name (str): Default region when creating new connections
            botocore_session (botocore.session.Session): Use this Botocore session instead of
                creating a new default one.
            profile_name (str): The name of a profile to use. If not given, then the default
                profile is used.
            **session_kwargs: Pass additional args for boto Session here
                (for additional args that boto3 might add in the future).
        &#34;&#34;&#34;
        # Easily grab all boto args passed into us...
        args = {k: v for k, v in locals().items() if v is not None}
        args.pop(&#39;self&#39;, None)
        args.pop(&#39;reset_session_when_activated&#39;, None)
        args.pop(&#39;session_kwargs&#39;, None)

        # Remember args...
        self.reset_session_when_activated = reset_session_when_activated
        self._session_kwargs = {**args, **session_kwargs}
        self._boto_obj_store = {}

    def context_resource_for_copy(
            self, *, current_context: XContext, copied_context: XContext
    ) -&gt; &#39;BotoSession&#39;:
        if self.reset_session_when_activated:
            self.reset_session()
        return self

    @property
    def session_kwargs(self) -&gt; Dict[str, Any]:
        return self._session_kwargs.copy()

    @session_kwargs.setter
    def session_kwargs(self, value: Dict[str, Any]):
        self._session_kwargs = {**value}
        self.reset_session()

    def reset_session(self):
        # We will lazily create session and their associated boto-objs in the future as needed.
        self._session = None
        self._boto_obj_store = {}

    _session: Optional[boto3.Session] = None
    _session_kwargs: dict
    _boto_obj_store: dict

    def _boto_obj_for_dependency(
            self,
            dependency: &#39;_BaseBotoClientOrResource&#39;,
            constructor: Callable,
            force_create: bool = False
    ):
        if not force_create and (boto_obj := self._boto_obj_store.get(dependency)):
            return boto_obj

        boto_obj = constructor()
        self._boto_obj_store[dependency] = boto_obj
        return boto_obj

    def _reset_boto_obj_for_dependency(self, dependency: &#39;_BaseBotoClientOrResource&#39;):
        self._boto_obj_store.pop(dependency, None)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="xinject.dependency.Dependency" href="../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="xboto.dependencies.BotoSession.__init_subclass__"><code class="name flex">
<span>def <span class="ident">__init_subclass__</span></span>(<span>thread_sharable=Default, attributes_to_skip_while_copying:Â Optional[Iterable[str]]Â =Â Default, **kwargs)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xinject.dependency.Dependency" href="../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></code>.<code><a title="xinject.dependency.Dependency.__init_subclass__" href="../xinject/dependency.html#xinject.dependency.Dependency.__init_subclass__">__init_subclass__</a></code>
</p>
<div class="desc inherited"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>thread_sharable</code></strong></dt>
<dd>If <code>False</code>: While a dependency is lazily auto-created, we will
ensure we do it per-thread, and not make it visible â€¦</dd>
</dl></div>
</dd>
<dt id="xboto.dependencies.BotoSession.grab"><code class="name flex">
<span>def <span class="ident">grab</span></span>(<span>) â€‘>Â ~T</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xinject.dependency.Dependency" href="../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></code>.<code><a title="xinject.dependency.Dependency.grab" href="../xinject/dependency.html#xinject.dependency.Dependency.grab">grab</a></code>
</p>
<div class="desc inherited"><p>Gets a potentially shared dependency from the current <code>udpend.context.XContext</code> â€¦</p></div>
</dd>
<dt id="xboto.dependencies.BotoSession.proxy"><code class="name flex">
<span>def <span class="ident">proxy</span></span>(<span>) â€‘>Â ~R</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xinject.dependency.Dependency" href="../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></code>.<code><a title="xinject.dependency.Dependency.proxy" href="../xinject/dependency.html#xinject.dependency.Dependency.proxy">proxy</a></code>
</p>
<div class="desc inherited"><p>Returns a proxy-object, that when and attribute is asked for, it will
proxy it to the current object of <code>cls</code> â€¦</p></div>
</dd>
<dt id="xboto.dependencies.BotoSession.proxy_attribute"><code class="name flex">
<span>def <span class="ident">proxy_attribute</span></span>(<span>attribute_name:Â str) â€‘>Â Any</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xinject.dependency.Dependency" href="../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></code>.<code><a title="xinject.dependency.Dependency.proxy_attribute" href="../xinject/dependency.html#xinject.dependency.Dependency.proxy_attribute">proxy_attribute</a></code>
</p>
<div class="desc inherited"><p>Returns a proxy-object, that when and attribute is asked for, it will
proxy it to the current attribute value on the current object of <code>cls</code> â€¦</p></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="xboto.dependencies.BotoSession.obj"><code class="name">var <span class="ident">obj</span> :Â <a title="xinject.dependency.Dependency" href="../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xinject.dependency.Dependency" href="../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></code>.<code><a title="xinject.dependency.Dependency.obj" href="../xinject/dependency.html#xinject.dependency.Dependency.obj">obj</a></code>
</p>
<div class="desc inherited"><p>class property/attribute that will return the current dependency for the subclass
it's asked on by calling <code>Dependency.grab</code>, passing no extra â€¦</p></div>
</dd>
<dt id="xboto.dependencies.BotoSession.session"><code class="name">var <span class="ident">session</span> :Â boto3.session.Session</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def session(self) -&gt; boto3.Session:
    if session := self._session:
        return session
    session = boto3.Session(**self._session_kwargs)
    self._session = session
    return session</code></pre>
</details>
</dd>
<dt id="xboto.dependencies.BotoSession.session_kwargs"><code class="name">var <span class="ident">session_kwargs</span> :Â Dict[str,Â Any]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def session_kwargs(self) -&gt; Dict[str, Any]:
    return self._session_kwargs.copy()</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="xboto.dependencies.BotoSession.__call__"><code class="name flex">
<span>def <span class="ident">__call__</span></span>(<span>self, func)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xinject.dependency.Dependency" href="../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></code>.<code><a title="xinject.dependency.Dependency.__call__" href="../xinject/dependency.html#xinject.dependency.Dependency.__call__">__call__</a></code>
</p>
<div class="desc inherited"><p>This makes Resource subclasses have an ability to be used as function decorators
by default unless this method is overriden to provide some other â€¦</p></div>
</dd>
<dt id="xboto.dependencies.BotoSession.__copy__"><code class="name flex">
<span>def <span class="ident">__copy__</span></span>(<span>self)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xinject.dependency.Dependency" href="../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></code>.<code><a title="xinject.dependency.Dependency.__copy__" href="../xinject/dependency.html#xinject.dependency.Dependency.__copy__">__copy__</a></code>
</p>
<div class="desc inherited"><p>Basic shallow copy protection
(I am wondering if I should just remove this default copy code) â€¦</p></div>
</dd>
<dt id="xboto.dependencies.BotoSession.context_resource_for_copy"><code class="name flex">
<span>def <span class="ident">context_resource_for_copy</span></span>(<span>self, *, current_context:Â <a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a>, copied_context:Â <a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a>) â€‘>Â <a title="xboto.dependencies.BotoSession" href="#xboto.dependencies.BotoSession">BotoSession</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def context_resource_for_copy(
        self, *, current_context: XContext, copied_context: XContext
) -&gt; &#39;BotoSession&#39;:
    if self.reset_session_when_activated:
        self.reset_session()
    return self</code></pre>
</details>
</dd>
<dt id="xboto.dependencies.BotoSession.reset_session"><code class="name flex">
<span>def <span class="ident">reset_session</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_session(self):
    # We will lazily create session and their associated boto-objs in the future as needed.
    self._session = None
    self._boto_obj_store = {}</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="xboto" href="index.html">xboto</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="xboto.dependencies.boto_clients" href="#xboto.dependencies.boto_clients">boto_clients</a></code></li>
<li><code><a title="xboto.dependencies.boto_resources" href="#xboto.dependencies.boto_resources">boto_resources</a></code></li>
<li><code><a title="xboto.dependencies.boto_session" href="#xboto.dependencies.boto_session">boto_session</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="xboto.dependencies.BotoClient" href="#xboto.dependencies.BotoClient">BotoClient</a></code></h4>
<ul class="two-column">
<li><code><a title="xboto.dependencies.BotoClient.__call__" href="../xinject/dependency.html#xboto.dependencies.BotoClient.__call__">__call__</a></code></li>
<li><code><a title="xboto.dependencies.BotoClient.__copy__" href="../xinject/dependency.html#xboto.dependencies.BotoClient.__copy__">__copy__</a></code></li>
<li><code><a title="xboto.dependencies.BotoClient.__init_subclass__" href="../xinject/dependency.html#xboto.dependencies.BotoClient.__init_subclass__">__init_subclass__</a></code></li>
<li><code><a title="xboto.dependencies.BotoClient.boto_client" href="#xboto.dependencies.BotoClient.boto_client">boto_client</a></code></li>
<li><code><a title="xboto.dependencies.BotoClient.get_dependency_cls" href="#xboto.dependencies.BotoClient.get_dependency_cls">get_dependency_cls</a></code></li>
<li><code><a title="xboto.dependencies.BotoClient.grab" href="../xinject/dependency.html#xboto.dependencies.BotoClient.grab">grab</a></code></li>
<li><code><a title="xboto.dependencies.BotoClient.obj" href="../xinject/dependency.html#xboto.dependencies.BotoClient.obj">obj</a></code></li>
<li><code><a title="xboto.dependencies.BotoClient.proxy" href="../xinject/dependency.html#xboto.dependencies.BotoClient.proxy">proxy</a></code></li>
<li><code><a title="xboto.dependencies.BotoClient.proxy_attribute" href="../xinject/dependency.html#xboto.dependencies.BotoClient.proxy_attribute">proxy_attribute</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="xboto.dependencies.BotoClients" href="#xboto.dependencies.BotoClients">BotoClients</a></code></h4>
<ul class="">
<li><code><a title="xboto.dependencies.BotoClients.AccessAnalyzer" href="#xboto.dependencies.BotoClients.AccessAnalyzer">AccessAnalyzer</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Account" href="#xboto.dependencies.BotoClients.Account">Account</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Acm" href="#xboto.dependencies.BotoClients.Acm">Acm</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Acm_Pca" href="#xboto.dependencies.BotoClients.Acm_Pca">Acm_Pca</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.AlexaForBusiness" href="#xboto.dependencies.BotoClients.AlexaForBusiness">AlexaForBusiness</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Amp" href="#xboto.dependencies.BotoClients.Amp">Amp</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Amplify" href="#xboto.dependencies.BotoClients.Amplify">Amplify</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.AmplifyBackend" href="#xboto.dependencies.BotoClients.AmplifyBackend">AmplifyBackend</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.AmplifyUiBuilder" href="#xboto.dependencies.BotoClients.AmplifyUiBuilder">AmplifyUiBuilder</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.ApiGateway" href="#xboto.dependencies.BotoClients.ApiGateway">ApiGateway</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.ApiGatewayManagementApi" href="#xboto.dependencies.BotoClients.ApiGatewayManagementApi">ApiGatewayManagementApi</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.ApiGatewayV2" href="#xboto.dependencies.BotoClients.ApiGatewayV2">ApiGatewayV2</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.AppConfig" href="#xboto.dependencies.BotoClients.AppConfig">AppConfig</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.AppConfigData" href="#xboto.dependencies.BotoClients.AppConfigData">AppConfigData</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.AppIntegrations" href="#xboto.dependencies.BotoClients.AppIntegrations">AppIntegrations</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Appflow" href="#xboto.dependencies.BotoClients.Appflow">Appflow</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Application_Autoscaling" href="#xboto.dependencies.BotoClients.Application_Autoscaling">Application_Autoscaling</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Application_Insights" href="#xboto.dependencies.BotoClients.Application_Insights">Application_Insights</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Applicationcostprofiler" href="#xboto.dependencies.BotoClients.Applicationcostprofiler">Applicationcostprofiler</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Appmesh" href="#xboto.dependencies.BotoClients.Appmesh">Appmesh</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Apprunner" href="#xboto.dependencies.BotoClients.Apprunner">Apprunner</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Appstream" href="#xboto.dependencies.BotoClients.Appstream">Appstream</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Appsync" href="#xboto.dependencies.BotoClients.Appsync">Appsync</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Arc_Zonal_Shift" href="#xboto.dependencies.BotoClients.Arc_Zonal_Shift">Arc_Zonal_Shift</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Athena" href="#xboto.dependencies.BotoClients.Athena">Athena</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.AuditManager" href="#xboto.dependencies.BotoClients.AuditManager">AuditManager</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Autoscaling" href="#xboto.dependencies.BotoClients.Autoscaling">Autoscaling</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Autoscaling_Plans" href="#xboto.dependencies.BotoClients.Autoscaling_Plans">Autoscaling_Plans</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Backup" href="#xboto.dependencies.BotoClients.Backup">Backup</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.BackupStorage" href="#xboto.dependencies.BotoClients.BackupStorage">BackupStorage</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Backup_Gateway" href="#xboto.dependencies.BotoClients.Backup_Gateway">Backup_Gateway</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Batch" href="#xboto.dependencies.BotoClients.Batch">Batch</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.BillingConductor" href="#xboto.dependencies.BotoClients.BillingConductor">BillingConductor</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Braket" href="#xboto.dependencies.BotoClients.Braket">Braket</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Budgets" href="#xboto.dependencies.BotoClients.Budgets">Budgets</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Ce" href="#xboto.dependencies.BotoClients.Ce">Ce</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Chime" href="#xboto.dependencies.BotoClients.Chime">Chime</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Chime_Sdk_Identity" href="#xboto.dependencies.BotoClients.Chime_Sdk_Identity">Chime_Sdk_Identity</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Chime_Sdk_Media_Pipelines" href="#xboto.dependencies.BotoClients.Chime_Sdk_Media_Pipelines">Chime_Sdk_Media_Pipelines</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Chime_Sdk_Meetings" href="#xboto.dependencies.BotoClients.Chime_Sdk_Meetings">Chime_Sdk_Meetings</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Chime_Sdk_Messaging" href="#xboto.dependencies.BotoClients.Chime_Sdk_Messaging">Chime_Sdk_Messaging</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Chime_Sdk_Voice" href="#xboto.dependencies.BotoClients.Chime_Sdk_Voice">Chime_Sdk_Voice</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Cleanrooms" href="#xboto.dependencies.BotoClients.Cleanrooms">Cleanrooms</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Cloud9" href="#xboto.dependencies.BotoClients.Cloud9">Cloud9</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Cloudcontrol" href="#xboto.dependencies.BotoClients.Cloudcontrol">Cloudcontrol</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Clouddirectory" href="#xboto.dependencies.BotoClients.Clouddirectory">Clouddirectory</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Cloudformation" href="#xboto.dependencies.BotoClients.Cloudformation">Cloudformation</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Cloudfront" href="#xboto.dependencies.BotoClients.Cloudfront">Cloudfront</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Cloudhsm" href="#xboto.dependencies.BotoClients.Cloudhsm">Cloudhsm</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Cloudhsmv2" href="#xboto.dependencies.BotoClients.Cloudhsmv2">Cloudhsmv2</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Cloudsearch" href="#xboto.dependencies.BotoClients.Cloudsearch">Cloudsearch</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Cloudsearchdomain" href="#xboto.dependencies.BotoClients.Cloudsearchdomain">Cloudsearchdomain</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Cloudtrail" href="#xboto.dependencies.BotoClients.Cloudtrail">Cloudtrail</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Cloudtrail_Data" href="#xboto.dependencies.BotoClients.Cloudtrail_Data">Cloudtrail_Data</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Cloudwatch" href="#xboto.dependencies.BotoClients.Cloudwatch">Cloudwatch</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.CodeArtifact" href="#xboto.dependencies.BotoClients.CodeArtifact">CodeArtifact</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.CodeBuild" href="#xboto.dependencies.BotoClients.CodeBuild">CodeBuild</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.CodeCatalyst" href="#xboto.dependencies.BotoClients.CodeCatalyst">CodeCatalyst</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.CodeCommit" href="#xboto.dependencies.BotoClients.CodeCommit">CodeCommit</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.CodeDeploy" href="#xboto.dependencies.BotoClients.CodeDeploy">CodeDeploy</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.CodePipeline" href="#xboto.dependencies.BotoClients.CodePipeline">CodePipeline</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.CodeguruProfiler" href="#xboto.dependencies.BotoClients.CodeguruProfiler">CodeguruProfiler</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Codeguru_Reviewer" href="#xboto.dependencies.BotoClients.Codeguru_Reviewer">Codeguru_Reviewer</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Codestar" href="#xboto.dependencies.BotoClients.Codestar">Codestar</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Codestar_Connections" href="#xboto.dependencies.BotoClients.Codestar_Connections">Codestar_Connections</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Codestar_Notifications" href="#xboto.dependencies.BotoClients.Codestar_Notifications">Codestar_Notifications</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Cognito_Identity" href="#xboto.dependencies.BotoClients.Cognito_Identity">Cognito_Identity</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Cognito_Idp" href="#xboto.dependencies.BotoClients.Cognito_Idp">Cognito_Idp</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Cognito_Sync" href="#xboto.dependencies.BotoClients.Cognito_Sync">Cognito_Sync</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Comprehend" href="#xboto.dependencies.BotoClients.Comprehend">Comprehend</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Comprehendmedical" href="#xboto.dependencies.BotoClients.Comprehendmedical">Comprehendmedical</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Compute_Optimizer" href="#xboto.dependencies.BotoClients.Compute_Optimizer">Compute_Optimizer</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Config" href="#xboto.dependencies.BotoClients.Config">Config</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Connect" href="#xboto.dependencies.BotoClients.Connect">Connect</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.ConnectCampaigns" href="#xboto.dependencies.BotoClients.ConnectCampaigns">ConnectCampaigns</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.ConnectCases" href="#xboto.dependencies.BotoClients.ConnectCases">ConnectCases</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.ConnectParticipant" href="#xboto.dependencies.BotoClients.ConnectParticipant">ConnectParticipant</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Connect_Contact_Lens" href="#xboto.dependencies.BotoClients.Connect_Contact_Lens">Connect_Contact_Lens</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.ControlTower" href="#xboto.dependencies.BotoClients.ControlTower">ControlTower</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Cur" href="#xboto.dependencies.BotoClients.Cur">Cur</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Customer_Profiles" href="#xboto.dependencies.BotoClients.Customer_Profiles">Customer_Profiles</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.DataBrew" href="#xboto.dependencies.BotoClients.DataBrew">DataBrew</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.DataExchange" href="#xboto.dependencies.BotoClients.DataExchange">DataExchange</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.DataPipeline" href="#xboto.dependencies.BotoClients.DataPipeline">DataPipeline</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.DataSync" href="#xboto.dependencies.BotoClients.DataSync">DataSync</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Dax" href="#xboto.dependencies.BotoClients.Dax">Dax</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Detective" href="#xboto.dependencies.BotoClients.Detective">Detective</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Devicefarm" href="#xboto.dependencies.BotoClients.Devicefarm">Devicefarm</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Devops_Guru" href="#xboto.dependencies.BotoClients.Devops_Guru">Devops_Guru</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.DirectConnect" href="#xboto.dependencies.BotoClients.DirectConnect">DirectConnect</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Discovery" href="#xboto.dependencies.BotoClients.Discovery">Discovery</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Dlm" href="#xboto.dependencies.BotoClients.Dlm">Dlm</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Dms" href="#xboto.dependencies.BotoClients.Dms">Dms</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Docdb" href="#xboto.dependencies.BotoClients.Docdb">Docdb</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Docdb_Elastic" href="#xboto.dependencies.BotoClients.Docdb_Elastic">Docdb_Elastic</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Drs" href="#xboto.dependencies.BotoClients.Drs">Drs</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Ds" href="#xboto.dependencies.BotoClients.Ds">Ds</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.DynamoDb" href="#xboto.dependencies.BotoClients.DynamoDb">DynamoDb</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.DynamoDbStreams" href="#xboto.dependencies.BotoClients.DynamoDbStreams">DynamoDbStreams</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Ebs" href="#xboto.dependencies.BotoClients.Ebs">Ebs</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Ec2" href="#xboto.dependencies.BotoClients.Ec2">Ec2</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Ec2_Instance_Connect" href="#xboto.dependencies.BotoClients.Ec2_Instance_Connect">Ec2_Instance_Connect</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Ecr" href="#xboto.dependencies.BotoClients.Ecr">Ecr</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Ecr_Public" href="#xboto.dependencies.BotoClients.Ecr_Public">Ecr_Public</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Ecs" href="#xboto.dependencies.BotoClients.Ecs">Ecs</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Efs" href="#xboto.dependencies.BotoClients.Efs">Efs</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Eks" href="#xboto.dependencies.BotoClients.Eks">Eks</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.ElasticBeanstalk" href="#xboto.dependencies.BotoClients.ElasticBeanstalk">ElasticBeanstalk</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.ElasticTranscoder" href="#xboto.dependencies.BotoClients.ElasticTranscoder">ElasticTranscoder</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Elastic_Inference" href="#xboto.dependencies.BotoClients.Elastic_Inference">Elastic_Inference</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Elasticache" href="#xboto.dependencies.BotoClients.Elasticache">Elasticache</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Elb" href="#xboto.dependencies.BotoClients.Elb">Elb</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Elbv2" href="#xboto.dependencies.BotoClients.Elbv2">Elbv2</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Emr" href="#xboto.dependencies.BotoClients.Emr">Emr</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Emr_Containers" href="#xboto.dependencies.BotoClients.Emr_Containers">Emr_Containers</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Emr_Serverless" href="#xboto.dependencies.BotoClients.Emr_Serverless">Emr_Serverless</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Es" href="#xboto.dependencies.BotoClients.Es">Es</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Events" href="#xboto.dependencies.BotoClients.Events">Events</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Evidently" href="#xboto.dependencies.BotoClients.Evidently">Evidently</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Finspace" href="#xboto.dependencies.BotoClients.Finspace">Finspace</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Finspace_Data" href="#xboto.dependencies.BotoClients.Finspace_Data">Finspace_Data</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Firehose" href="#xboto.dependencies.BotoClients.Firehose">Firehose</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Fis" href="#xboto.dependencies.BotoClients.Fis">Fis</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Fms" href="#xboto.dependencies.BotoClients.Fms">Fms</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Forecast" href="#xboto.dependencies.BotoClients.Forecast">Forecast</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Forecastquery" href="#xboto.dependencies.BotoClients.Forecastquery">Forecastquery</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Frauddetector" href="#xboto.dependencies.BotoClients.Frauddetector">Frauddetector</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Fsx" href="#xboto.dependencies.BotoClients.Fsx">Fsx</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Gamelift" href="#xboto.dependencies.BotoClients.Gamelift">Gamelift</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Gamesparks" href="#xboto.dependencies.BotoClients.Gamesparks">Gamesparks</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Glacier" href="#xboto.dependencies.BotoClients.Glacier">Glacier</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Globalaccelerator" href="#xboto.dependencies.BotoClients.Globalaccelerator">Globalaccelerator</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Glue" href="#xboto.dependencies.BotoClients.Glue">Glue</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Grafana" href="#xboto.dependencies.BotoClients.Grafana">Grafana</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Greengrass" href="#xboto.dependencies.BotoClients.Greengrass">Greengrass</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Greengrassv2" href="#xboto.dependencies.BotoClients.Greengrassv2">Greengrassv2</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Groundstation" href="#xboto.dependencies.BotoClients.Groundstation">Groundstation</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Guardduty" href="#xboto.dependencies.BotoClients.Guardduty">Guardduty</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Health" href="#xboto.dependencies.BotoClients.Health">Health</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Healthlake" href="#xboto.dependencies.BotoClients.Healthlake">Healthlake</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Honeycode" href="#xboto.dependencies.BotoClients.Honeycode">Honeycode</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Iam" href="#xboto.dependencies.BotoClients.Iam">Iam</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.IdentityStore" href="#xboto.dependencies.BotoClients.IdentityStore">IdentityStore</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.ImageBuilder" href="#xboto.dependencies.BotoClients.ImageBuilder">ImageBuilder</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.ImportExport" href="#xboto.dependencies.BotoClients.ImportExport">ImportExport</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Inspector" href="#xboto.dependencies.BotoClients.Inspector">Inspector</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Inspector2" href="#xboto.dependencies.BotoClients.Inspector2">Inspector2</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Iot" href="#xboto.dependencies.BotoClients.Iot">Iot</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Iot1Click_Devices" href="#xboto.dependencies.BotoClients.Iot1Click_Devices">Iot1Click_Devices</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Iot1Click_Projects" href="#xboto.dependencies.BotoClients.Iot1Click_Projects">Iot1Click_Projects</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.IotAnalytics" href="#xboto.dependencies.BotoClients.IotAnalytics">IotAnalytics</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.IotDeviceAdvisor" href="#xboto.dependencies.BotoClients.IotDeviceAdvisor">IotDeviceAdvisor</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.IotEvents" href="#xboto.dependencies.BotoClients.IotEvents">IotEvents</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.IotEvents_Data" href="#xboto.dependencies.BotoClients.IotEvents_Data">IotEvents_Data</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.IotFleethub" href="#xboto.dependencies.BotoClients.IotFleethub">IotFleethub</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.IotFleetwise" href="#xboto.dependencies.BotoClients.IotFleetwise">IotFleetwise</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.IotSecureTunneling" href="#xboto.dependencies.BotoClients.IotSecureTunneling">IotSecureTunneling</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.IotSitewise" href="#xboto.dependencies.BotoClients.IotSitewise">IotSitewise</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.IotThingsgraph" href="#xboto.dependencies.BotoClients.IotThingsgraph">IotThingsgraph</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.IotTwinmaker" href="#xboto.dependencies.BotoClients.IotTwinmaker">IotTwinmaker</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.IotWireless" href="#xboto.dependencies.BotoClients.IotWireless">IotWireless</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Iot_Data" href="#xboto.dependencies.BotoClients.Iot_Data">Iot_Data</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Iot_Jobs_Data" href="#xboto.dependencies.BotoClients.Iot_Jobs_Data">Iot_Jobs_Data</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Iot_Roborunner" href="#xboto.dependencies.BotoClients.Iot_Roborunner">Iot_Roborunner</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Ivs" href="#xboto.dependencies.BotoClients.Ivs">Ivs</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Ivschat" href="#xboto.dependencies.BotoClients.Ivschat">Ivschat</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Kafka" href="#xboto.dependencies.BotoClients.Kafka">Kafka</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Kafkaconnect" href="#xboto.dependencies.BotoClients.Kafkaconnect">Kafkaconnect</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Kendra" href="#xboto.dependencies.BotoClients.Kendra">Kendra</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Kendra_Ranking" href="#xboto.dependencies.BotoClients.Kendra_Ranking">Kendra_Ranking</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Keyspaces" href="#xboto.dependencies.BotoClients.Keyspaces">Keyspaces</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Kinesis" href="#xboto.dependencies.BotoClients.Kinesis">Kinesis</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.KinesisAnalytics" href="#xboto.dependencies.BotoClients.KinesisAnalytics">KinesisAnalytics</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.KinesisAnalyticsv2" href="#xboto.dependencies.BotoClients.KinesisAnalyticsv2">KinesisAnalyticsv2</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Kinesis_Video_Archived_Media" href="#xboto.dependencies.BotoClients.Kinesis_Video_Archived_Media">Kinesis_Video_Archived_Media</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Kinesis_Video_Media" href="#xboto.dependencies.BotoClients.Kinesis_Video_Media">Kinesis_Video_Media</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Kinesis_Video_Signaling" href="#xboto.dependencies.BotoClients.Kinesis_Video_Signaling">Kinesis_Video_Signaling</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Kinesis_Video_Webrtc_Storage" href="#xboto.dependencies.BotoClients.Kinesis_Video_Webrtc_Storage">Kinesis_Video_Webrtc_Storage</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Kinesisvideo" href="#xboto.dependencies.BotoClients.Kinesisvideo">Kinesisvideo</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Kms" href="#xboto.dependencies.BotoClients.Kms">Kms</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Lakeformation" href="#xboto.dependencies.BotoClients.Lakeformation">Lakeformation</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Lambda_" href="#xboto.dependencies.BotoClients.Lambda_">Lambda_</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Lex_Models" href="#xboto.dependencies.BotoClients.Lex_Models">Lex_Models</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Lex_Runtime" href="#xboto.dependencies.BotoClients.Lex_Runtime">Lex_Runtime</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Lexv2_Models" href="#xboto.dependencies.BotoClients.Lexv2_Models">Lexv2_Models</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Lexv2_Runtime" href="#xboto.dependencies.BotoClients.Lexv2_Runtime">Lexv2_Runtime</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.License_Manager" href="#xboto.dependencies.BotoClients.License_Manager">License_Manager</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.License_Manager_Linux_Subscriptions" href="#xboto.dependencies.BotoClients.License_Manager_Linux_Subscriptions">License_Manager_Linux_Subscriptions</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.License_Manager_User_Subscriptions" href="#xboto.dependencies.BotoClients.License_Manager_User_Subscriptions">License_Manager_User_Subscriptions</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Lightsail" href="#xboto.dependencies.BotoClients.Lightsail">Lightsail</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Location" href="#xboto.dependencies.BotoClients.Location">Location</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Logs" href="#xboto.dependencies.BotoClients.Logs">Logs</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.LookoutEquipment" href="#xboto.dependencies.BotoClients.LookoutEquipment">LookoutEquipment</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.LookoutMetrics" href="#xboto.dependencies.BotoClients.LookoutMetrics">LookoutMetrics</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.LookoutVision" href="#xboto.dependencies.BotoClients.LookoutVision">LookoutVision</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.M2" href="#xboto.dependencies.BotoClients.M2">M2</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.MachineLearning" href="#xboto.dependencies.BotoClients.MachineLearning">MachineLearning</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Macie" href="#xboto.dependencies.BotoClients.Macie">Macie</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Macie2" href="#xboto.dependencies.BotoClients.Macie2">Macie2</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.ManagedBlockchain" href="#xboto.dependencies.BotoClients.ManagedBlockchain">ManagedBlockchain</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.MarketPlace_Catalog" href="#xboto.dependencies.BotoClients.MarketPlace_Catalog">MarketPlace_Catalog</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.MarketPlace_Entitlement" href="#xboto.dependencies.BotoClients.MarketPlace_Entitlement">MarketPlace_Entitlement</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.MarketPlacecommerceanalytics" href="#xboto.dependencies.BotoClients.MarketPlacecommerceanalytics">MarketPlacecommerceanalytics</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.MediaConnect" href="#xboto.dependencies.BotoClients.MediaConnect">MediaConnect</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.MediaConvert" href="#xboto.dependencies.BotoClients.MediaConvert">MediaConvert</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.MediaLive" href="#xboto.dependencies.BotoClients.MediaLive">MediaLive</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.MediaPackage" href="#xboto.dependencies.BotoClients.MediaPackage">MediaPackage</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.MediaPackage_Vod" href="#xboto.dependencies.BotoClients.MediaPackage_Vod">MediaPackage_Vod</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.MediaStore" href="#xboto.dependencies.BotoClients.MediaStore">MediaStore</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.MediaStore_Data" href="#xboto.dependencies.BotoClients.MediaStore_Data">MediaStore_Data</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.MediaTailor" href="#xboto.dependencies.BotoClients.MediaTailor">MediaTailor</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.MemoryDb" href="#xboto.dependencies.BotoClients.MemoryDb">MemoryDb</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.MeteringMarketplace" href="#xboto.dependencies.BotoClients.MeteringMarketplace">MeteringMarketplace</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Mgh" href="#xboto.dependencies.BotoClients.Mgh">Mgh</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Mgn" href="#xboto.dependencies.BotoClients.Mgn">Mgn</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.MigrationHubOrchestrator" href="#xboto.dependencies.BotoClients.MigrationHubOrchestrator">MigrationHubOrchestrator</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.MigrationHubStrategy" href="#xboto.dependencies.BotoClients.MigrationHubStrategy">MigrationHubStrategy</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.MigrationHub_Config" href="#xboto.dependencies.BotoClients.MigrationHub_Config">MigrationHub_Config</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Migration_Hub_Refactor_Spaces" href="#xboto.dependencies.BotoClients.Migration_Hub_Refactor_Spaces">Migration_Hub_Refactor_Spaces</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Mobile" href="#xboto.dependencies.BotoClients.Mobile">Mobile</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Mq" href="#xboto.dependencies.BotoClients.Mq">Mq</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Mturk" href="#xboto.dependencies.BotoClients.Mturk">Mturk</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Mwaa" href="#xboto.dependencies.BotoClients.Mwaa">Mwaa</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Neptune" href="#xboto.dependencies.BotoClients.Neptune">Neptune</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Network_Firewall" href="#xboto.dependencies.BotoClients.Network_Firewall">Network_Firewall</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Networkmanager" href="#xboto.dependencies.BotoClients.Networkmanager">Networkmanager</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Nimble" href="#xboto.dependencies.BotoClients.Nimble">Nimble</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Oam" href="#xboto.dependencies.BotoClients.Oam">Oam</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Omics" href="#xboto.dependencies.BotoClients.Omics">Omics</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Opensearch" href="#xboto.dependencies.BotoClients.Opensearch">Opensearch</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.OpensearchServerless" href="#xboto.dependencies.BotoClients.OpensearchServerless">OpensearchServerless</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Opsworks" href="#xboto.dependencies.BotoClients.Opsworks">Opsworks</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Opsworkscm" href="#xboto.dependencies.BotoClients.Opsworkscm">Opsworkscm</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Organizations" href="#xboto.dependencies.BotoClients.Organizations">Organizations</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Outposts" href="#xboto.dependencies.BotoClients.Outposts">Outposts</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Panorama" href="#xboto.dependencies.BotoClients.Panorama">Panorama</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Personalize" href="#xboto.dependencies.BotoClients.Personalize">Personalize</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Personalize_Events" href="#xboto.dependencies.BotoClients.Personalize_Events">Personalize_Events</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Personalize_Runtime" href="#xboto.dependencies.BotoClients.Personalize_Runtime">Personalize_Runtime</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Pi" href="#xboto.dependencies.BotoClients.Pi">Pi</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Pinpoint" href="#xboto.dependencies.BotoClients.Pinpoint">Pinpoint</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Pinpoint_Email" href="#xboto.dependencies.BotoClients.Pinpoint_Email">Pinpoint_Email</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Pinpoint_Sms_Voice" href="#xboto.dependencies.BotoClients.Pinpoint_Sms_Voice">Pinpoint_Sms_Voice</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Pinpoint_Sms_Voice_V2" href="#xboto.dependencies.BotoClients.Pinpoint_Sms_Voice_V2">Pinpoint_Sms_Voice_V2</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Pipes" href="#xboto.dependencies.BotoClients.Pipes">Pipes</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Polly" href="#xboto.dependencies.BotoClients.Polly">Polly</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Pricing" href="#xboto.dependencies.BotoClients.Pricing">Pricing</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Privatenetworks" href="#xboto.dependencies.BotoClients.Privatenetworks">Privatenetworks</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Proton" href="#xboto.dependencies.BotoClients.Proton">Proton</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Qldb" href="#xboto.dependencies.BotoClients.Qldb">Qldb</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Qldb_Session" href="#xboto.dependencies.BotoClients.Qldb_Session">Qldb_Session</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Quicksight" href="#xboto.dependencies.BotoClients.Quicksight">Quicksight</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Ram" href="#xboto.dependencies.BotoClients.Ram">Ram</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Rbin" href="#xboto.dependencies.BotoClients.Rbin">Rbin</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Rds" href="#xboto.dependencies.BotoClients.Rds">Rds</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Rds_Data" href="#xboto.dependencies.BotoClients.Rds_Data">Rds_Data</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Redshift" href="#xboto.dependencies.BotoClients.Redshift">Redshift</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Redshift_Data" href="#xboto.dependencies.BotoClients.Redshift_Data">Redshift_Data</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Redshift_Serverless" href="#xboto.dependencies.BotoClients.Redshift_Serverless">Redshift_Serverless</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Rekognition" href="#xboto.dependencies.BotoClients.Rekognition">Rekognition</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Resiliencehub" href="#xboto.dependencies.BotoClients.Resiliencehub">Resiliencehub</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.ResourceGroupStaggingApi" href="#xboto.dependencies.BotoClients.ResourceGroupStaggingApi">ResourceGroupStaggingApi</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Resource_Explorer_2" href="#xboto.dependencies.BotoClients.Resource_Explorer_2">Resource_Explorer_2</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Resource_Groups" href="#xboto.dependencies.BotoClients.Resource_Groups">Resource_Groups</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Robomaker" href="#xboto.dependencies.BotoClients.Robomaker">Robomaker</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Rolesanywhere" href="#xboto.dependencies.BotoClients.Rolesanywhere">Rolesanywhere</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Route53" href="#xboto.dependencies.BotoClients.Route53">Route53</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Route53Domains" href="#xboto.dependencies.BotoClients.Route53Domains">Route53Domains</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Route53Resolver" href="#xboto.dependencies.BotoClients.Route53Resolver">Route53Resolver</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Route53_Recovery_Cluster" href="#xboto.dependencies.BotoClients.Route53_Recovery_Cluster">Route53_Recovery_Cluster</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Route53_Recovery_Control_Config" href="#xboto.dependencies.BotoClients.Route53_Recovery_Control_Config">Route53_Recovery_Control_Config</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Route53_Recovery_Readiness" href="#xboto.dependencies.BotoClients.Route53_Recovery_Readiness">Route53_Recovery_Readiness</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Rum" href="#xboto.dependencies.BotoClients.Rum">Rum</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.S3" href="#xboto.dependencies.BotoClients.S3">S3</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.S3Control" href="#xboto.dependencies.BotoClients.S3Control">S3Control</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.S3Outposts" href="#xboto.dependencies.BotoClients.S3Outposts">S3Outposts</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Sagemaker" href="#xboto.dependencies.BotoClients.Sagemaker">Sagemaker</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Sagemaker_A2I_Runtime" href="#xboto.dependencies.BotoClients.Sagemaker_A2I_Runtime">Sagemaker_A2I_Runtime</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Sagemaker_Edge" href="#xboto.dependencies.BotoClients.Sagemaker_Edge">Sagemaker_Edge</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Sagemaker_Featurestore_Runtime" href="#xboto.dependencies.BotoClients.Sagemaker_Featurestore_Runtime">Sagemaker_Featurestore_Runtime</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Sagemaker_Geospatial" href="#xboto.dependencies.BotoClients.Sagemaker_Geospatial">Sagemaker_Geospatial</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Sagemaker_Metrics" href="#xboto.dependencies.BotoClients.Sagemaker_Metrics">Sagemaker_Metrics</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Sagemaker_Runtime" href="#xboto.dependencies.BotoClients.Sagemaker_Runtime">Sagemaker_Runtime</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.SavingsPlans" href="#xboto.dependencies.BotoClients.SavingsPlans">SavingsPlans</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Scheduler" href="#xboto.dependencies.BotoClients.Scheduler">Scheduler</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Schemas" href="#xboto.dependencies.BotoClients.Schemas">Schemas</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Sdb" href="#xboto.dependencies.BotoClients.Sdb">Sdb</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Secretsmanager" href="#xboto.dependencies.BotoClients.Secretsmanager">Secretsmanager</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Securityhub" href="#xboto.dependencies.BotoClients.Securityhub">Securityhub</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Securitylake" href="#xboto.dependencies.BotoClients.Securitylake">Securitylake</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Serverlessrepo" href="#xboto.dependencies.BotoClients.Serverlessrepo">Serverlessrepo</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.ServiceCatalog" href="#xboto.dependencies.BotoClients.ServiceCatalog">ServiceCatalog</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.ServiceCatalog_Appregistry" href="#xboto.dependencies.BotoClients.ServiceCatalog_Appregistry">ServiceCatalog_Appregistry</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.ServiceDiscovery" href="#xboto.dependencies.BotoClients.ServiceDiscovery">ServiceDiscovery</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Service_Quotas" href="#xboto.dependencies.BotoClients.Service_Quotas">Service_Quotas</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Ses" href="#xboto.dependencies.BotoClients.Ses">Ses</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Sesv2" href="#xboto.dependencies.BotoClients.Sesv2">Sesv2</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Shield" href="#xboto.dependencies.BotoClients.Shield">Shield</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Signer" href="#xboto.dependencies.BotoClients.Signer">Signer</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Simspaceweaver" href="#xboto.dependencies.BotoClients.Simspaceweaver">Simspaceweaver</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Sms" href="#xboto.dependencies.BotoClients.Sms">Sms</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Sms_Voice" href="#xboto.dependencies.BotoClients.Sms_Voice">Sms_Voice</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Snow_Device_Management" href="#xboto.dependencies.BotoClients.Snow_Device_Management">Snow_Device_Management</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Snowball" href="#xboto.dependencies.BotoClients.Snowball">Snowball</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Sns" href="#xboto.dependencies.BotoClients.Sns">Sns</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Sqs" href="#xboto.dependencies.BotoClients.Sqs">Sqs</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Ssm" href="#xboto.dependencies.BotoClients.Ssm">Ssm</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Ssm_Contacts" href="#xboto.dependencies.BotoClients.Ssm_Contacts">Ssm_Contacts</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Ssm_Incidents" href="#xboto.dependencies.BotoClients.Ssm_Incidents">Ssm_Incidents</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Ssm_Sap" href="#xboto.dependencies.BotoClients.Ssm_Sap">Ssm_Sap</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Sso" href="#xboto.dependencies.BotoClients.Sso">Sso</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Sso_Admin" href="#xboto.dependencies.BotoClients.Sso_Admin">Sso_Admin</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Sso_Oidc" href="#xboto.dependencies.BotoClients.Sso_Oidc">Sso_Oidc</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.StepFunctions" href="#xboto.dependencies.BotoClients.StepFunctions">StepFunctions</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.StorageGateway" href="#xboto.dependencies.BotoClients.StorageGateway">StorageGateway</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Sts" href="#xboto.dependencies.BotoClients.Sts">Sts</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Support" href="#xboto.dependencies.BotoClients.Support">Support</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Support_App" href="#xboto.dependencies.BotoClients.Support_App">Support_App</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Swf" href="#xboto.dependencies.BotoClients.Swf">Swf</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Synthetics" href="#xboto.dependencies.BotoClients.Synthetics">Synthetics</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Textract" href="#xboto.dependencies.BotoClients.Textract">Textract</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Timestream_Query" href="#xboto.dependencies.BotoClients.Timestream_Query">Timestream_Query</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Timestream_Write" href="#xboto.dependencies.BotoClients.Timestream_Write">Timestream_Write</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Transcribe" href="#xboto.dependencies.BotoClients.Transcribe">Transcribe</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Transfer" href="#xboto.dependencies.BotoClients.Transfer">Transfer</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Translate" href="#xboto.dependencies.BotoClients.Translate">Translate</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Voice_Id" href="#xboto.dependencies.BotoClients.Voice_Id">Voice_Id</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Waf" href="#xboto.dependencies.BotoClients.Waf">Waf</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Waf_Regional" href="#xboto.dependencies.BotoClients.Waf_Regional">Waf_Regional</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Wafv2" href="#xboto.dependencies.BotoClients.Wafv2">Wafv2</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.WellArchitected" href="#xboto.dependencies.BotoClients.WellArchitected">WellArchitected</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Wisdom" href="#xboto.dependencies.BotoClients.Wisdom">Wisdom</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Workdocs" href="#xboto.dependencies.BotoClients.Workdocs">Workdocs</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Worklink" href="#xboto.dependencies.BotoClients.Worklink">Worklink</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Workmail" href="#xboto.dependencies.BotoClients.Workmail">Workmail</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.WorkmailMessageFlow" href="#xboto.dependencies.BotoClients.WorkmailMessageFlow">WorkmailMessageFlow</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Workspaces" href="#xboto.dependencies.BotoClients.Workspaces">Workspaces</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Workspaces_Web" href="#xboto.dependencies.BotoClients.Workspaces_Web">Workspaces_Web</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.Xray" href="#xboto.dependencies.BotoClients.Xray">Xray</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.__call__" href="../xinject/dependency.html#xboto.dependencies.BotoClients.__call__">__call__</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.__copy__" href="../xinject/dependency.html#xboto.dependencies.BotoClients.__copy__">__copy__</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.__init_subclass__" href="../xinject/dependency.html#xboto.dependencies.BotoClients.__init_subclass__">__init_subclass__</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.accessanalyzer" href="#xboto.dependencies.BotoClients.accessanalyzer">accessanalyzer</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.account" href="#xboto.dependencies.BotoClients.account">account</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.acm" href="#xboto.dependencies.BotoClients.acm">acm</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.acm_pca" href="#xboto.dependencies.BotoClients.acm_pca">acm_pca</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.alexaforbusiness" href="#xboto.dependencies.BotoClients.alexaforbusiness">alexaforbusiness</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.amp" href="#xboto.dependencies.BotoClients.amp">amp</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.amplify" href="#xboto.dependencies.BotoClients.amplify">amplify</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.amplifybackend" href="#xboto.dependencies.BotoClients.amplifybackend">amplifybackend</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.amplifyuibuilder" href="#xboto.dependencies.BotoClients.amplifyuibuilder">amplifyuibuilder</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.apigateway" href="#xboto.dependencies.BotoClients.apigateway">apigateway</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.apigatewaymanagementapi" href="#xboto.dependencies.BotoClients.apigatewaymanagementapi">apigatewaymanagementapi</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.apigatewayv2" href="#xboto.dependencies.BotoClients.apigatewayv2">apigatewayv2</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.appconfig" href="#xboto.dependencies.BotoClients.appconfig">appconfig</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.appconfigdata" href="#xboto.dependencies.BotoClients.appconfigdata">appconfigdata</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.appflow" href="#xboto.dependencies.BotoClients.appflow">appflow</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.appintegrations" href="#xboto.dependencies.BotoClients.appintegrations">appintegrations</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.application_autoscaling" href="#xboto.dependencies.BotoClients.application_autoscaling">application_autoscaling</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.application_insights" href="#xboto.dependencies.BotoClients.application_insights">application_insights</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.applicationcostprofiler" href="#xboto.dependencies.BotoClients.applicationcostprofiler">applicationcostprofiler</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.appmesh" href="#xboto.dependencies.BotoClients.appmesh">appmesh</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.apprunner" href="#xboto.dependencies.BotoClients.apprunner">apprunner</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.appstream" href="#xboto.dependencies.BotoClients.appstream">appstream</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.appsync" href="#xboto.dependencies.BotoClients.appsync">appsync</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.arc_zonal_shift" href="#xboto.dependencies.BotoClients.arc_zonal_shift">arc_zonal_shift</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.athena" href="#xboto.dependencies.BotoClients.athena">athena</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.auditmanager" href="#xboto.dependencies.BotoClients.auditmanager">auditmanager</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.autoscaling" href="#xboto.dependencies.BotoClients.autoscaling">autoscaling</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.autoscaling_plans" href="#xboto.dependencies.BotoClients.autoscaling_plans">autoscaling_plans</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.backup" href="#xboto.dependencies.BotoClients.backup">backup</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.backup_gateway" href="#xboto.dependencies.BotoClients.backup_gateway">backup_gateway</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.backupstorage" href="#xboto.dependencies.BotoClients.backupstorage">backupstorage</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.batch" href="#xboto.dependencies.BotoClients.batch">batch</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.billingconductor" href="#xboto.dependencies.BotoClients.billingconductor">billingconductor</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.braket" href="#xboto.dependencies.BotoClients.braket">braket</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.budgets" href="#xboto.dependencies.BotoClients.budgets">budgets</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.ce" href="#xboto.dependencies.BotoClients.ce">ce</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.chime" href="#xboto.dependencies.BotoClients.chime">chime</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.chime_sdk_identity" href="#xboto.dependencies.BotoClients.chime_sdk_identity">chime_sdk_identity</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.chime_sdk_media_pipelines" href="#xboto.dependencies.BotoClients.chime_sdk_media_pipelines">chime_sdk_media_pipelines</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.chime_sdk_meetings" href="#xboto.dependencies.BotoClients.chime_sdk_meetings">chime_sdk_meetings</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.chime_sdk_messaging" href="#xboto.dependencies.BotoClients.chime_sdk_messaging">chime_sdk_messaging</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.chime_sdk_voice" href="#xboto.dependencies.BotoClients.chime_sdk_voice">chime_sdk_voice</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.cleanrooms" href="#xboto.dependencies.BotoClients.cleanrooms">cleanrooms</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.cloud9" href="#xboto.dependencies.BotoClients.cloud9">cloud9</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.cloudcontrol" href="#xboto.dependencies.BotoClients.cloudcontrol">cloudcontrol</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.clouddirectory" href="#xboto.dependencies.BotoClients.clouddirectory">clouddirectory</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.cloudformation" href="#xboto.dependencies.BotoClients.cloudformation">cloudformation</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.cloudfront" href="#xboto.dependencies.BotoClients.cloudfront">cloudfront</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.cloudhsm" href="#xboto.dependencies.BotoClients.cloudhsm">cloudhsm</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.cloudhsmv2" href="#xboto.dependencies.BotoClients.cloudhsmv2">cloudhsmv2</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.cloudsearch" href="#xboto.dependencies.BotoClients.cloudsearch">cloudsearch</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.cloudsearchdomain" href="#xboto.dependencies.BotoClients.cloudsearchdomain">cloudsearchdomain</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.cloudtrail" href="#xboto.dependencies.BotoClients.cloudtrail">cloudtrail</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.cloudtrail_data" href="#xboto.dependencies.BotoClients.cloudtrail_data">cloudtrail_data</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.cloudwatch" href="#xboto.dependencies.BotoClients.cloudwatch">cloudwatch</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.codeartifact" href="#xboto.dependencies.BotoClients.codeartifact">codeartifact</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.codebuild" href="#xboto.dependencies.BotoClients.codebuild">codebuild</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.codecatalyst" href="#xboto.dependencies.BotoClients.codecatalyst">codecatalyst</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.codecommit" href="#xboto.dependencies.BotoClients.codecommit">codecommit</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.codedeploy" href="#xboto.dependencies.BotoClients.codedeploy">codedeploy</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.codeguru_reviewer" href="#xboto.dependencies.BotoClients.codeguru_reviewer">codeguru_reviewer</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.codeguruprofiler" href="#xboto.dependencies.BotoClients.codeguruprofiler">codeguruprofiler</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.codepipeline" href="#xboto.dependencies.BotoClients.codepipeline">codepipeline</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.codestar" href="#xboto.dependencies.BotoClients.codestar">codestar</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.codestar_connections" href="#xboto.dependencies.BotoClients.codestar_connections">codestar_connections</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.codestar_notifications" href="#xboto.dependencies.BotoClients.codestar_notifications">codestar_notifications</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.cognito_identity" href="#xboto.dependencies.BotoClients.cognito_identity">cognito_identity</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.cognito_idp" href="#xboto.dependencies.BotoClients.cognito_idp">cognito_idp</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.cognito_sync" href="#xboto.dependencies.BotoClients.cognito_sync">cognito_sync</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.comprehend" href="#xboto.dependencies.BotoClients.comprehend">comprehend</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.comprehendmedical" href="#xboto.dependencies.BotoClients.comprehendmedical">comprehendmedical</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.compute_optimizer" href="#xboto.dependencies.BotoClients.compute_optimizer">compute_optimizer</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.config" href="#xboto.dependencies.BotoClients.config">config</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.connect" href="#xboto.dependencies.BotoClients.connect">connect</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.connect_contact_lens" href="#xboto.dependencies.BotoClients.connect_contact_lens">connect_contact_lens</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.connectcampaigns" href="#xboto.dependencies.BotoClients.connectcampaigns">connectcampaigns</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.connectcases" href="#xboto.dependencies.BotoClients.connectcases">connectcases</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.connectparticipant" href="#xboto.dependencies.BotoClients.connectparticipant">connectparticipant</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.controltower" href="#xboto.dependencies.BotoClients.controltower">controltower</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.cur" href="#xboto.dependencies.BotoClients.cur">cur</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.customer_profiles" href="#xboto.dependencies.BotoClients.customer_profiles">customer_profiles</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.databrew" href="#xboto.dependencies.BotoClients.databrew">databrew</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.dataexchange" href="#xboto.dependencies.BotoClients.dataexchange">dataexchange</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.datapipeline" href="#xboto.dependencies.BotoClients.datapipeline">datapipeline</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.datasync" href="#xboto.dependencies.BotoClients.datasync">datasync</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.dax" href="#xboto.dependencies.BotoClients.dax">dax</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.detective" href="#xboto.dependencies.BotoClients.detective">detective</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.devicefarm" href="#xboto.dependencies.BotoClients.devicefarm">devicefarm</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.devops_guru" href="#xboto.dependencies.BotoClients.devops_guru">devops_guru</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.directconnect" href="#xboto.dependencies.BotoClients.directconnect">directconnect</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.discovery" href="#xboto.dependencies.BotoClients.discovery">discovery</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.dlm" href="#xboto.dependencies.BotoClients.dlm">dlm</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.dms" href="#xboto.dependencies.BotoClients.dms">dms</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.docdb" href="#xboto.dependencies.BotoClients.docdb">docdb</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.docdb_elastic" href="#xboto.dependencies.BotoClients.docdb_elastic">docdb_elastic</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.drs" href="#xboto.dependencies.BotoClients.drs">drs</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.ds" href="#xboto.dependencies.BotoClients.ds">ds</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.dynamodb" href="#xboto.dependencies.BotoClients.dynamodb">dynamodb</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.dynamodbstreams" href="#xboto.dependencies.BotoClients.dynamodbstreams">dynamodbstreams</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.ebs" href="#xboto.dependencies.BotoClients.ebs">ebs</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.ec2" href="#xboto.dependencies.BotoClients.ec2">ec2</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.ec2_instance_connect" href="#xboto.dependencies.BotoClients.ec2_instance_connect">ec2_instance_connect</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.ecr" href="#xboto.dependencies.BotoClients.ecr">ecr</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.ecr_public" href="#xboto.dependencies.BotoClients.ecr_public">ecr_public</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.ecs" href="#xboto.dependencies.BotoClients.ecs">ecs</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.efs" href="#xboto.dependencies.BotoClients.efs">efs</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.eks" href="#xboto.dependencies.BotoClients.eks">eks</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.elastic_inference" href="#xboto.dependencies.BotoClients.elastic_inference">elastic_inference</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.elasticache" href="#xboto.dependencies.BotoClients.elasticache">elasticache</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.elasticbeanstalk" href="#xboto.dependencies.BotoClients.elasticbeanstalk">elasticbeanstalk</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.elastictranscoder" href="#xboto.dependencies.BotoClients.elastictranscoder">elastictranscoder</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.elb" href="#xboto.dependencies.BotoClients.elb">elb</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.elbv2" href="#xboto.dependencies.BotoClients.elbv2">elbv2</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.emr" href="#xboto.dependencies.BotoClients.emr">emr</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.emr_containers" href="#xboto.dependencies.BotoClients.emr_containers">emr_containers</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.emr_serverless" href="#xboto.dependencies.BotoClients.emr_serverless">emr_serverless</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.es" href="#xboto.dependencies.BotoClients.es">es</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.events" href="#xboto.dependencies.BotoClients.events">events</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.evidently" href="#xboto.dependencies.BotoClients.evidently">evidently</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.finspace" href="#xboto.dependencies.BotoClients.finspace">finspace</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.finspace_data" href="#xboto.dependencies.BotoClients.finspace_data">finspace_data</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.firehose" href="#xboto.dependencies.BotoClients.firehose">firehose</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.fis" href="#xboto.dependencies.BotoClients.fis">fis</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.fms" href="#xboto.dependencies.BotoClients.fms">fms</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.forecast" href="#xboto.dependencies.BotoClients.forecast">forecast</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.forecastquery" href="#xboto.dependencies.BotoClients.forecastquery">forecastquery</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.frauddetector" href="#xboto.dependencies.BotoClients.frauddetector">frauddetector</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.fsx" href="#xboto.dependencies.BotoClients.fsx">fsx</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.gamelift" href="#xboto.dependencies.BotoClients.gamelift">gamelift</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.gamesparks" href="#xboto.dependencies.BotoClients.gamesparks">gamesparks</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.glacier" href="#xboto.dependencies.BotoClients.glacier">glacier</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.globalaccelerator" href="#xboto.dependencies.BotoClients.globalaccelerator">globalaccelerator</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.glue" href="#xboto.dependencies.BotoClients.glue">glue</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.grab" href="../xinject/dependency.html#xboto.dependencies.BotoClients.grab">grab</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.grafana" href="#xboto.dependencies.BotoClients.grafana">grafana</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.greengrass" href="#xboto.dependencies.BotoClients.greengrass">greengrass</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.greengrassv2" href="#xboto.dependencies.BotoClients.greengrassv2">greengrassv2</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.groundstation" href="#xboto.dependencies.BotoClients.groundstation">groundstation</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.guardduty" href="#xboto.dependencies.BotoClients.guardduty">guardduty</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.health" href="#xboto.dependencies.BotoClients.health">health</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.healthlake" href="#xboto.dependencies.BotoClients.healthlake">healthlake</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.honeycode" href="#xboto.dependencies.BotoClients.honeycode">honeycode</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.iam" href="#xboto.dependencies.BotoClients.iam">iam</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.identitystore" href="#xboto.dependencies.BotoClients.identitystore">identitystore</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.imagebuilder" href="#xboto.dependencies.BotoClients.imagebuilder">imagebuilder</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.importexport" href="#xboto.dependencies.BotoClients.importexport">importexport</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.inspector" href="#xboto.dependencies.BotoClients.inspector">inspector</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.inspector2" href="#xboto.dependencies.BotoClients.inspector2">inspector2</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.iot" href="#xboto.dependencies.BotoClients.iot">iot</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.iot1click_devices" href="#xboto.dependencies.BotoClients.iot1click_devices">iot1click_devices</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.iot1click_projects" href="#xboto.dependencies.BotoClients.iot1click_projects">iot1click_projects</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.iot_data" href="#xboto.dependencies.BotoClients.iot_data">iot_data</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.iot_jobs_data" href="#xboto.dependencies.BotoClients.iot_jobs_data">iot_jobs_data</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.iot_roborunner" href="#xboto.dependencies.BotoClients.iot_roborunner">iot_roborunner</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.iotanalytics" href="#xboto.dependencies.BotoClients.iotanalytics">iotanalytics</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.iotdeviceadvisor" href="#xboto.dependencies.BotoClients.iotdeviceadvisor">iotdeviceadvisor</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.iotevents" href="#xboto.dependencies.BotoClients.iotevents">iotevents</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.iotevents_data" href="#xboto.dependencies.BotoClients.iotevents_data">iotevents_data</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.iotfleethub" href="#xboto.dependencies.BotoClients.iotfleethub">iotfleethub</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.iotfleetwise" href="#xboto.dependencies.BotoClients.iotfleetwise">iotfleetwise</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.iotsecuretunneling" href="#xboto.dependencies.BotoClients.iotsecuretunneling">iotsecuretunneling</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.iotsitewise" href="#xboto.dependencies.BotoClients.iotsitewise">iotsitewise</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.iotthingsgraph" href="#xboto.dependencies.BotoClients.iotthingsgraph">iotthingsgraph</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.iottwinmaker" href="#xboto.dependencies.BotoClients.iottwinmaker">iottwinmaker</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.iotwireless" href="#xboto.dependencies.BotoClients.iotwireless">iotwireless</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.ivs" href="#xboto.dependencies.BotoClients.ivs">ivs</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.ivschat" href="#xboto.dependencies.BotoClients.ivschat">ivschat</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.kafka" href="#xboto.dependencies.BotoClients.kafka">kafka</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.kafkaconnect" href="#xboto.dependencies.BotoClients.kafkaconnect">kafkaconnect</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.kendra" href="#xboto.dependencies.BotoClients.kendra">kendra</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.kendra_ranking" href="#xboto.dependencies.BotoClients.kendra_ranking">kendra_ranking</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.keyspaces" href="#xboto.dependencies.BotoClients.keyspaces">keyspaces</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.kinesis" href="#xboto.dependencies.BotoClients.kinesis">kinesis</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.kinesis_video_archived_media" href="#xboto.dependencies.BotoClients.kinesis_video_archived_media">kinesis_video_archived_media</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.kinesis_video_media" href="#xboto.dependencies.BotoClients.kinesis_video_media">kinesis_video_media</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.kinesis_video_signaling" href="#xboto.dependencies.BotoClients.kinesis_video_signaling">kinesis_video_signaling</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.kinesis_video_webrtc_storage" href="#xboto.dependencies.BotoClients.kinesis_video_webrtc_storage">kinesis_video_webrtc_storage</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.kinesisanalytics" href="#xboto.dependencies.BotoClients.kinesisanalytics">kinesisanalytics</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.kinesisanalyticsv2" href="#xboto.dependencies.BotoClients.kinesisanalyticsv2">kinesisanalyticsv2</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.kinesisvideo" href="#xboto.dependencies.BotoClients.kinesisvideo">kinesisvideo</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.kms" href="#xboto.dependencies.BotoClients.kms">kms</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.lakeformation" href="#xboto.dependencies.BotoClients.lakeformation">lakeformation</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.lambda_" href="#xboto.dependencies.BotoClients.lambda_">lambda_</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.lex_models" href="#xboto.dependencies.BotoClients.lex_models">lex_models</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.lex_runtime" href="#xboto.dependencies.BotoClients.lex_runtime">lex_runtime</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.lexv2_models" href="#xboto.dependencies.BotoClients.lexv2_models">lexv2_models</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.lexv2_runtime" href="#xboto.dependencies.BotoClients.lexv2_runtime">lexv2_runtime</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.license_manager" href="#xboto.dependencies.BotoClients.license_manager">license_manager</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.license_manager_linux_subscriptions" href="#xboto.dependencies.BotoClients.license_manager_linux_subscriptions">license_manager_linux_subscriptions</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.license_manager_user_subscriptions" href="#xboto.dependencies.BotoClients.license_manager_user_subscriptions">license_manager_user_subscriptions</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.lightsail" href="#xboto.dependencies.BotoClients.lightsail">lightsail</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.location" href="#xboto.dependencies.BotoClients.location">location</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.logs" href="#xboto.dependencies.BotoClients.logs">logs</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.lookoutequipment" href="#xboto.dependencies.BotoClients.lookoutequipment">lookoutequipment</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.lookoutmetrics" href="#xboto.dependencies.BotoClients.lookoutmetrics">lookoutmetrics</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.lookoutvision" href="#xboto.dependencies.BotoClients.lookoutvision">lookoutvision</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.m2" href="#xboto.dependencies.BotoClients.m2">m2</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.machinelearning" href="#xboto.dependencies.BotoClients.machinelearning">machinelearning</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.macie" href="#xboto.dependencies.BotoClients.macie">macie</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.macie2" href="#xboto.dependencies.BotoClients.macie2">macie2</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.managedblockchain" href="#xboto.dependencies.BotoClients.managedblockchain">managedblockchain</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.marketplace_catalog" href="#xboto.dependencies.BotoClients.marketplace_catalog">marketplace_catalog</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.marketplace_entitlement" href="#xboto.dependencies.BotoClients.marketplace_entitlement">marketplace_entitlement</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.marketplacecommerceanalytics" href="#xboto.dependencies.BotoClients.marketplacecommerceanalytics">marketplacecommerceanalytics</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.mediaconnect" href="#xboto.dependencies.BotoClients.mediaconnect">mediaconnect</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.mediaconvert" href="#xboto.dependencies.BotoClients.mediaconvert">mediaconvert</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.medialive" href="#xboto.dependencies.BotoClients.medialive">medialive</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.mediapackage" href="#xboto.dependencies.BotoClients.mediapackage">mediapackage</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.mediapackage_vod" href="#xboto.dependencies.BotoClients.mediapackage_vod">mediapackage_vod</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.mediastore" href="#xboto.dependencies.BotoClients.mediastore">mediastore</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.mediastore_data" href="#xboto.dependencies.BotoClients.mediastore_data">mediastore_data</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.mediatailor" href="#xboto.dependencies.BotoClients.mediatailor">mediatailor</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.memorydb" href="#xboto.dependencies.BotoClients.memorydb">memorydb</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.meteringmarketplace" href="#xboto.dependencies.BotoClients.meteringmarketplace">meteringmarketplace</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.mgh" href="#xboto.dependencies.BotoClients.mgh">mgh</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.mgn" href="#xboto.dependencies.BotoClients.mgn">mgn</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.migration_hub_refactor_spaces" href="#xboto.dependencies.BotoClients.migration_hub_refactor_spaces">migration_hub_refactor_spaces</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.migrationhub_config" href="#xboto.dependencies.BotoClients.migrationhub_config">migrationhub_config</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.migrationhuborchestrator" href="#xboto.dependencies.BotoClients.migrationhuborchestrator">migrationhuborchestrator</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.migrationhubstrategy" href="#xboto.dependencies.BotoClients.migrationhubstrategy">migrationhubstrategy</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.mobile" href="#xboto.dependencies.BotoClients.mobile">mobile</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.mq" href="#xboto.dependencies.BotoClients.mq">mq</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.mturk" href="#xboto.dependencies.BotoClients.mturk">mturk</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.mwaa" href="#xboto.dependencies.BotoClients.mwaa">mwaa</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.neptune" href="#xboto.dependencies.BotoClients.neptune">neptune</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.network_firewall" href="#xboto.dependencies.BotoClients.network_firewall">network_firewall</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.networkmanager" href="#xboto.dependencies.BotoClients.networkmanager">networkmanager</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.nimble" href="#xboto.dependencies.BotoClients.nimble">nimble</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.oam" href="#xboto.dependencies.BotoClients.oam">oam</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.obj" href="../xinject/dependency.html#xboto.dependencies.BotoClients.obj">obj</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.omics" href="#xboto.dependencies.BotoClients.omics">omics</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.opensearch" href="#xboto.dependencies.BotoClients.opensearch">opensearch</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.opensearchserverless" href="#xboto.dependencies.BotoClients.opensearchserverless">opensearchserverless</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.opsworks" href="#xboto.dependencies.BotoClients.opsworks">opsworks</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.opsworkscm" href="#xboto.dependencies.BotoClients.opsworkscm">opsworkscm</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.organizations" href="#xboto.dependencies.BotoClients.organizations">organizations</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.outposts" href="#xboto.dependencies.BotoClients.outposts">outposts</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.panorama" href="#xboto.dependencies.BotoClients.panorama">panorama</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.personalize" href="#xboto.dependencies.BotoClients.personalize">personalize</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.personalize_events" href="#xboto.dependencies.BotoClients.personalize_events">personalize_events</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.personalize_runtime" href="#xboto.dependencies.BotoClients.personalize_runtime">personalize_runtime</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.pi" href="#xboto.dependencies.BotoClients.pi">pi</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.pinpoint" href="#xboto.dependencies.BotoClients.pinpoint">pinpoint</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.pinpoint_email" href="#xboto.dependencies.BotoClients.pinpoint_email">pinpoint_email</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.pinpoint_sms_voice" href="#xboto.dependencies.BotoClients.pinpoint_sms_voice">pinpoint_sms_voice</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.pinpoint_sms_voice_v2" href="#xboto.dependencies.BotoClients.pinpoint_sms_voice_v2">pinpoint_sms_voice_v2</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.pipes" href="#xboto.dependencies.BotoClients.pipes">pipes</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.polly" href="#xboto.dependencies.BotoClients.polly">polly</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.pricing" href="#xboto.dependencies.BotoClients.pricing">pricing</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.privatenetworks" href="#xboto.dependencies.BotoClients.privatenetworks">privatenetworks</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.proton" href="#xboto.dependencies.BotoClients.proton">proton</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.proxy" href="../xinject/dependency.html#xboto.dependencies.BotoClients.proxy">proxy</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.proxy_attribute" href="../xinject/dependency.html#xboto.dependencies.BotoClients.proxy_attribute">proxy_attribute</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.qldb" href="#xboto.dependencies.BotoClients.qldb">qldb</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.qldb_session" href="#xboto.dependencies.BotoClients.qldb_session">qldb_session</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.quicksight" href="#xboto.dependencies.BotoClients.quicksight">quicksight</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.ram" href="#xboto.dependencies.BotoClients.ram">ram</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.rbin" href="#xboto.dependencies.BotoClients.rbin">rbin</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.rds" href="#xboto.dependencies.BotoClients.rds">rds</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.rds_data" href="#xboto.dependencies.BotoClients.rds_data">rds_data</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.redshift" href="#xboto.dependencies.BotoClients.redshift">redshift</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.redshift_data" href="#xboto.dependencies.BotoClients.redshift_data">redshift_data</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.redshift_serverless" href="#xboto.dependencies.BotoClients.redshift_serverless">redshift_serverless</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.rekognition" href="#xboto.dependencies.BotoClients.rekognition">rekognition</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.resiliencehub" href="#xboto.dependencies.BotoClients.resiliencehub">resiliencehub</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.resource_explorer_2" href="#xboto.dependencies.BotoClients.resource_explorer_2">resource_explorer_2</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.resource_groups" href="#xboto.dependencies.BotoClients.resource_groups">resource_groups</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.resourcegroupstaggingapi" href="#xboto.dependencies.BotoClients.resourcegroupstaggingapi">resourcegroupstaggingapi</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.robomaker" href="#xboto.dependencies.BotoClients.robomaker">robomaker</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.rolesanywhere" href="#xboto.dependencies.BotoClients.rolesanywhere">rolesanywhere</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.route53" href="#xboto.dependencies.BotoClients.route53">route53</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.route53_recovery_cluster" href="#xboto.dependencies.BotoClients.route53_recovery_cluster">route53_recovery_cluster</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.route53_recovery_control_config" href="#xboto.dependencies.BotoClients.route53_recovery_control_config">route53_recovery_control_config</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.route53_recovery_readiness" href="#xboto.dependencies.BotoClients.route53_recovery_readiness">route53_recovery_readiness</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.route53domains" href="#xboto.dependencies.BotoClients.route53domains">route53domains</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.route53resolver" href="#xboto.dependencies.BotoClients.route53resolver">route53resolver</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.rum" href="#xboto.dependencies.BotoClients.rum">rum</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.s3" href="#xboto.dependencies.BotoClients.s3">s3</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.s3control" href="#xboto.dependencies.BotoClients.s3control">s3control</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.s3outposts" href="#xboto.dependencies.BotoClients.s3outposts">s3outposts</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.sagemaker" href="#xboto.dependencies.BotoClients.sagemaker">sagemaker</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.sagemaker_a2i_runtime" href="#xboto.dependencies.BotoClients.sagemaker_a2i_runtime">sagemaker_a2i_runtime</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.sagemaker_edge" href="#xboto.dependencies.BotoClients.sagemaker_edge">sagemaker_edge</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.sagemaker_featurestore_runtime" href="#xboto.dependencies.BotoClients.sagemaker_featurestore_runtime">sagemaker_featurestore_runtime</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.sagemaker_geospatial" href="#xboto.dependencies.BotoClients.sagemaker_geospatial">sagemaker_geospatial</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.sagemaker_metrics" href="#xboto.dependencies.BotoClients.sagemaker_metrics">sagemaker_metrics</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.sagemaker_runtime" href="#xboto.dependencies.BotoClients.sagemaker_runtime">sagemaker_runtime</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.savingsplans" href="#xboto.dependencies.BotoClients.savingsplans">savingsplans</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.scheduler" href="#xboto.dependencies.BotoClients.scheduler">scheduler</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.schemas" href="#xboto.dependencies.BotoClients.schemas">schemas</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.sdb" href="#xboto.dependencies.BotoClients.sdb">sdb</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.secretsmanager" href="#xboto.dependencies.BotoClients.secretsmanager">secretsmanager</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.securityhub" href="#xboto.dependencies.BotoClients.securityhub">securityhub</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.securitylake" href="#xboto.dependencies.BotoClients.securitylake">securitylake</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.serverlessrepo" href="#xboto.dependencies.BotoClients.serverlessrepo">serverlessrepo</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.service_quotas" href="#xboto.dependencies.BotoClients.service_quotas">service_quotas</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.servicecatalog" href="#xboto.dependencies.BotoClients.servicecatalog">servicecatalog</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.servicecatalog_appregistry" href="#xboto.dependencies.BotoClients.servicecatalog_appregistry">servicecatalog_appregistry</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.servicediscovery" href="#xboto.dependencies.BotoClients.servicediscovery">servicediscovery</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.ses" href="#xboto.dependencies.BotoClients.ses">ses</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.sesv2" href="#xboto.dependencies.BotoClients.sesv2">sesv2</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.shield" href="#xboto.dependencies.BotoClients.shield">shield</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.signer" href="#xboto.dependencies.BotoClients.signer">signer</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.simspaceweaver" href="#xboto.dependencies.BotoClients.simspaceweaver">simspaceweaver</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.sms" href="#xboto.dependencies.BotoClients.sms">sms</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.sms_voice" href="#xboto.dependencies.BotoClients.sms_voice">sms_voice</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.snow_device_management" href="#xboto.dependencies.BotoClients.snow_device_management">snow_device_management</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.snowball" href="#xboto.dependencies.BotoClients.snowball">snowball</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.sns" href="#xboto.dependencies.BotoClients.sns">sns</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.sqs" href="#xboto.dependencies.BotoClients.sqs">sqs</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.ssm" href="#xboto.dependencies.BotoClients.ssm">ssm</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.ssm_contacts" href="#xboto.dependencies.BotoClients.ssm_contacts">ssm_contacts</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.ssm_incidents" href="#xboto.dependencies.BotoClients.ssm_incidents">ssm_incidents</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.ssm_sap" href="#xboto.dependencies.BotoClients.ssm_sap">ssm_sap</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.sso" href="#xboto.dependencies.BotoClients.sso">sso</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.sso_admin" href="#xboto.dependencies.BotoClients.sso_admin">sso_admin</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.sso_oidc" href="#xboto.dependencies.BotoClients.sso_oidc">sso_oidc</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.stepfunctions" href="#xboto.dependencies.BotoClients.stepfunctions">stepfunctions</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.storagegateway" href="#xboto.dependencies.BotoClients.storagegateway">storagegateway</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.sts" href="#xboto.dependencies.BotoClients.sts">sts</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.support" href="#xboto.dependencies.BotoClients.support">support</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.support_app" href="#xboto.dependencies.BotoClients.support_app">support_app</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.swf" href="#xboto.dependencies.BotoClients.swf">swf</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.synthetics" href="#xboto.dependencies.BotoClients.synthetics">synthetics</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.textract" href="#xboto.dependencies.BotoClients.textract">textract</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.timestream_query" href="#xboto.dependencies.BotoClients.timestream_query">timestream_query</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.timestream_write" href="#xboto.dependencies.BotoClients.timestream_write">timestream_write</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.transcribe" href="#xboto.dependencies.BotoClients.transcribe">transcribe</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.transfer" href="#xboto.dependencies.BotoClients.transfer">transfer</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.translate" href="#xboto.dependencies.BotoClients.translate">translate</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.voice_id" href="#xboto.dependencies.BotoClients.voice_id">voice_id</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.waf" href="#xboto.dependencies.BotoClients.waf">waf</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.waf_regional" href="#xboto.dependencies.BotoClients.waf_regional">waf_regional</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.wafv2" href="#xboto.dependencies.BotoClients.wafv2">wafv2</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.wellarchitected" href="#xboto.dependencies.BotoClients.wellarchitected">wellarchitected</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.wisdom" href="#xboto.dependencies.BotoClients.wisdom">wisdom</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.workdocs" href="#xboto.dependencies.BotoClients.workdocs">workdocs</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.worklink" href="#xboto.dependencies.BotoClients.worklink">worklink</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.workmail" href="#xboto.dependencies.BotoClients.workmail">workmail</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.workmailmessageflow" href="#xboto.dependencies.BotoClients.workmailmessageflow">workmailmessageflow</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.workspaces" href="#xboto.dependencies.BotoClients.workspaces">workspaces</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.workspaces_web" href="#xboto.dependencies.BotoClients.workspaces_web">workspaces_web</a></code></li>
<li><code><a title="xboto.dependencies.BotoClients.xray" href="#xboto.dependencies.BotoClients.xray">xray</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="xboto.dependencies.BotoResource" href="#xboto.dependencies.BotoResource">BotoResource</a></code></h4>
<ul class="two-column">
<li><code><a title="xboto.dependencies.BotoResource.__call__" href="../xinject/dependency.html#xboto.dependencies.BotoResource.__call__">__call__</a></code></li>
<li><code><a title="xboto.dependencies.BotoResource.__copy__" href="../xinject/dependency.html#xboto.dependencies.BotoResource.__copy__">__copy__</a></code></li>
<li><code><a title="xboto.dependencies.BotoResource.__init_subclass__" href="../xinject/dependency.html#xboto.dependencies.BotoResource.__init_subclass__">__init_subclass__</a></code></li>
<li><code><a title="xboto.dependencies.BotoResource.boto_resource" href="#xboto.dependencies.BotoResource.boto_resource">boto_resource</a></code></li>
<li><code><a title="xboto.dependencies.BotoResource.get_dependency_cls" href="#xboto.dependencies.BotoResource.get_dependency_cls">get_dependency_cls</a></code></li>
<li><code><a title="xboto.dependencies.BotoResource.grab" href="../xinject/dependency.html#xboto.dependencies.BotoResource.grab">grab</a></code></li>
<li><code><a title="xboto.dependencies.BotoResource.obj" href="../xinject/dependency.html#xboto.dependencies.BotoResource.obj">obj</a></code></li>
<li><code><a title="xboto.dependencies.BotoResource.proxy" href="../xinject/dependency.html#xboto.dependencies.BotoResource.proxy">proxy</a></code></li>
<li><code><a title="xboto.dependencies.BotoResource.proxy_attribute" href="../xinject/dependency.html#xboto.dependencies.BotoResource.proxy_attribute">proxy_attribute</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="xboto.dependencies.BotoResources" href="#xboto.dependencies.BotoResources">BotoResources</a></code></h4>
<ul class="two-column">
<li><code><a title="xboto.dependencies.BotoResources.CloudFormation" href="#xboto.dependencies.BotoResources.CloudFormation">CloudFormation</a></code></li>
<li><code><a title="xboto.dependencies.BotoResources.CloudWatch" href="#xboto.dependencies.BotoResources.CloudWatch">CloudWatch</a></code></li>
<li><code><a title="xboto.dependencies.BotoResources.DynamoDB" href="#xboto.dependencies.BotoResources.DynamoDB">DynamoDB</a></code></li>
<li><code><a title="xboto.dependencies.BotoResources.Ec2" href="#xboto.dependencies.BotoResources.Ec2">Ec2</a></code></li>
<li><code><a title="xboto.dependencies.BotoResources.Glacier" href="#xboto.dependencies.BotoResources.Glacier">Glacier</a></code></li>
<li><code><a title="xboto.dependencies.BotoResources.Iam" href="#xboto.dependencies.BotoResources.Iam">Iam</a></code></li>
<li><code><a title="xboto.dependencies.BotoResources.Ns" href="#xboto.dependencies.BotoResources.Ns">Ns</a></code></li>
<li><code><a title="xboto.dependencies.BotoResources.OpsWorks" href="#xboto.dependencies.BotoResources.OpsWorks">OpsWorks</a></code></li>
<li><code><a title="xboto.dependencies.BotoResources.S3" href="#xboto.dependencies.BotoResources.S3">S3</a></code></li>
<li><code><a title="xboto.dependencies.BotoResources.Sqs" href="#xboto.dependencies.BotoResources.Sqs">Sqs</a></code></li>
<li><code><a title="xboto.dependencies.BotoResources.__call__" href="../xinject/dependency.html#xboto.dependencies.BotoResources.__call__">__call__</a></code></li>
<li><code><a title="xboto.dependencies.BotoResources.__copy__" href="../xinject/dependency.html#xboto.dependencies.BotoResources.__copy__">__copy__</a></code></li>
<li><code><a title="xboto.dependencies.BotoResources.__init_subclass__" href="../xinject/dependency.html#xboto.dependencies.BotoResources.__init_subclass__">__init_subclass__</a></code></li>
<li><code><a title="xboto.dependencies.BotoResources.cloudformation" href="#xboto.dependencies.BotoResources.cloudformation">cloudformation</a></code></li>
<li><code><a title="xboto.dependencies.BotoResources.cloudwatch" href="#xboto.dependencies.BotoResources.cloudwatch">cloudwatch</a></code></li>
<li><code><a title="xboto.dependencies.BotoResources.dynamodb" href="#xboto.dependencies.BotoResources.dynamodb">dynamodb</a></code></li>
<li><code><a title="xboto.dependencies.BotoResources.ec2" href="#xboto.dependencies.BotoResources.ec2">ec2</a></code></li>
<li><code><a title="xboto.dependencies.BotoResources.glacier" href="#xboto.dependencies.BotoResources.glacier">glacier</a></code></li>
<li><code><a title="xboto.dependencies.BotoResources.grab" href="../xinject/dependency.html#xboto.dependencies.BotoResources.grab">grab</a></code></li>
<li><code><a title="xboto.dependencies.BotoResources.iam" href="#xboto.dependencies.BotoResources.iam">iam</a></code></li>
<li><code><a title="xboto.dependencies.BotoResources.ns" href="#xboto.dependencies.BotoResources.ns">ns</a></code></li>
<li><code><a title="xboto.dependencies.BotoResources.obj" href="../xinject/dependency.html#xboto.dependencies.BotoResources.obj">obj</a></code></li>
<li><code><a title="xboto.dependencies.BotoResources.opsworks" href="#xboto.dependencies.BotoResources.opsworks">opsworks</a></code></li>
<li><code><a title="xboto.dependencies.BotoResources.proxy" href="../xinject/dependency.html#xboto.dependencies.BotoResources.proxy">proxy</a></code></li>
<li><code><a title="xboto.dependencies.BotoResources.proxy_attribute" href="../xinject/dependency.html#xboto.dependencies.BotoResources.proxy_attribute">proxy_attribute</a></code></li>
<li><code><a title="xboto.dependencies.BotoResources.s3" href="#xboto.dependencies.BotoResources.s3">s3</a></code></li>
<li><code><a title="xboto.dependencies.BotoResources.sqs" href="#xboto.dependencies.BotoResources.sqs">sqs</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="xboto.dependencies.BotoSession" href="#xboto.dependencies.BotoSession">BotoSession</a></code></h4>
<ul class="">
<li><code><a title="xboto.dependencies.BotoSession.__call__" href="../xinject/dependency.html#xboto.dependencies.BotoSession.__call__">__call__</a></code></li>
<li><code><a title="xboto.dependencies.BotoSession.__copy__" href="../xinject/dependency.html#xboto.dependencies.BotoSession.__copy__">__copy__</a></code></li>
<li><code><a title="xboto.dependencies.BotoSession.__init_subclass__" href="../xinject/dependency.html#xboto.dependencies.BotoSession.__init_subclass__">__init_subclass__</a></code></li>
<li><code><a title="xboto.dependencies.BotoSession.context_resource_for_copy" href="#xboto.dependencies.BotoSession.context_resource_for_copy">context_resource_for_copy</a></code></li>
<li><code><a title="xboto.dependencies.BotoSession.grab" href="../xinject/dependency.html#xboto.dependencies.BotoSession.grab">grab</a></code></li>
<li><code><a title="xboto.dependencies.BotoSession.obj" href="../xinject/dependency.html#xboto.dependencies.BotoSession.obj">obj</a></code></li>
<li><code><a title="xboto.dependencies.BotoSession.proxy" href="../xinject/dependency.html#xboto.dependencies.BotoSession.proxy">proxy</a></code></li>
<li><code><a title="xboto.dependencies.BotoSession.proxy_attribute" href="../xinject/dependency.html#xboto.dependencies.BotoSession.proxy_attribute">proxy_attribute</a></code></li>
<li><code><a title="xboto.dependencies.BotoSession.reset_session" href="#xboto.dependencies.BotoSession.reset_session">reset_session</a></code></li>
<li><code><a title="xboto.dependencies.BotoSession.session" href="#xboto.dependencies.BotoSession.session">session</a></code></li>
<li><code><a title="xboto.dependencies.BotoSession.session_kwargs" href="#xboto.dependencies.BotoSession.session_kwargs">session_kwargs</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>